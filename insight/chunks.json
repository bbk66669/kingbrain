[
  {
    "filePath": "/root/kk/src/agent/agent_decide_and_execute.py",
    "startLine": 32,
    "endLine": 84,
    "signature": "AsyncFunctionDef:agent_decide_and_execute",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Async函数 agent_decide_and_execute\n# Params: signal:Signal=None, price:float=None, broker:BrokerAPI=None\nasync def agent_decide_and_execute(\n    signal: Signal, price: float, broker: BrokerAPI,\n    *, qty: Optional[float] = None, prompt: str = \"\",\n    extra: dict | None = None, logger: logging.Logger | None = None,\n) -> None:\n    log = logger or logging.getLogger(\"Agent\")\n    curr_dir = await PositionGuard().get()\n\n    if signal == \"HOLD\" or curr_dir == signal:\n        return\n\n    if curr_dir and curr_dir != signal:\n        await broker.close_all()\n        trailing_mgr().cancel()\n        await PositionGuard().reset()\n\n    t0 = time.time()\n    res = await (broker.open_long if signal == \"BUY\" else broker.open_short)(\n        qty=qty, price=price\n    )\n    order_latency_seconds.observe(time.time() - t0)\n    okx_orders_total.labels(signal).inc()\n\n    from src.utils.config_loader import load as _load_cfg\n    pct = _load_cfg().get(\"risk\", {}).get(\"trail_sl_pct\", 0.0)\n    if pct > 0:\n        trailing_mgr().start(signal, price, pct)\n\n    await PositionGuard().update(signal)\n\n    pnl    = float(extra.get(\"pnl\", 0))    if extra else 0\n    equity = float(extra.get(\"equity\", 0)) if extra else 0\n    if equity: equity_usdt.set(equity)\n\n    try:\n        _weaviate().collections.get(\"TradeLog\").data.insert({\n            \"timestamp\":            int(time.time() * 1000),\n            \"symbol\":               broker.symbol,\n            \"signal\":               signal,\n            \"price\":                price,\n            \"size\":                 qty,\n            \"leverage\":             getattr(broker, \"leverage\", None),\n            \"order_id\":             res.get(\"id\", \"\"),\n            \"status\":               res.get(\"status\", \"\"),\n            \"prompt\":               prompt,\n            \"extra\":                json.dumps(extra or {}),\n            \"pnl_realized\":         pnl,\n            \"equity\":               equity,\n            \"trail_sl_pct\":         pct,\n            \"trail_sl_hit\":         \"false\",\n        })\n    except Exception as e:\n        log.warning(\"Weaviate insert failed: %s\", e)",
    "tags": [
      "time",
      "config",
      "update_logic",
      "curr",
      "broker",
      "await",
      "get",
      "none",
      "dir",
      "float",
      "error_handling",
      "signal",
      "api",
      "price",
      "qty",
      "extra",
      "pct",
      "equity"
    ],
    "calls": [
      "PositionGuard",
      "_load_cfg",
      "_weaviate",
      "agent_decide_and_execute",
      "await",
      "cancel",
      "close_all",
      "dumps",
      "float",
      "get",
      "getLogger",
      "getattr",
      "inc",
      "insert",
      "int",
      "labels",
      "observe",
      "reset",
      "set",
      "start",
      "time",
      "trailing_mgr",
      "update",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/agent_decide_and_execute.py",
    "startLine": 66,
    "endLine": 84,
    "signature": "Try:Try",
    "parentSignature": [
      "AsyncFunctionDef:agent_decide_and_execute"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Try:Try\n# Params: 无\n    try:\n        _weaviate().collections.get(\"TradeLog\").data.insert({\n            \"timestamp\":            int(time.time() * 1000),\n            \"symbol\":               broker.symbol,\n            \"signal\":               signal,\n            \"price\":                price,\n            \"size\":                 qty,\n            \"leverage\":             getattr(broker, \"leverage\", None),\n            \"order_id\":             res.get(\"id\", \"\"),\n            \"status\":               res.get(\"status\", \"\"),\n            \"prompt\":               prompt,\n            \"extra\":                json.dumps(extra or {}),\n            \"pnl_realized\":         pnl,\n            \"equity\":               equity,\n            \"trail_sl_pct\":         pct,\n            \"trail_sl_hit\":         \"false\",\n        })\n    except Exception as e:\n        log.warning(\"Weaviate insert failed: %s\", e)",
    "tags": [
      "time",
      "res",
      "weaviate",
      "broker",
      "leverage",
      "get",
      "prompt",
      "error_handling",
      "signal",
      "status",
      "pnl",
      "price",
      "insert",
      "extra",
      "symbol"
    ],
    "calls": [
      "_weaviate",
      "dumps",
      "get",
      "getattr",
      "insert",
      "int",
      "time",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/agent_stub.py",
    "startLine": 18,
    "endLine": 52,
    "signature": "FunctionDef:execute_signal",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 execute_signal\n# Params: symbol:str=None, signal:str=None, capital:float=None, risk_pct:float=None, sl_pct:None=0.01, tp_pct:None=0.02\ndef execute_signal(symbol: str, signal: str, capital: float, risk_pct: float, sl_pct=0.01, tp_pct=0.02):\n    price = get_latest_price(symbol)\n    client = get_client()\n    try:\n        collection = client.collections.get(\"TradeLog\")\n        ts = datetime.now(timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\"\n\n        size = calc_size(capital, risk_pct, price)\n        sl, tp = calc_sl_tp(price, sl_pct, tp_pct)\n        order = {}\n        order_status = \"NOSIGNAL\"\n        if signal in (\"BUY\", \"SELL\"):\n            order = place_order(symbol, signal, size, \"MARKET\")\n            order_status = \"FILLED\"\n\n        log = {\n            \"timestamp\": ts,\n            \"symbol\": symbol,\n            \"price\": price,\n            \"signal\": signal,\n            \"size\": size,\n            \"sl\": sl,\n            \"tp\": tp,\n            \"strategy_name\": \"agent_stub\",\n            \"strategy_params\": str({\"risk_pct\": risk_pct, \"sl_pct\": sl_pct, \"tp_pct\": tp_pct}),\n            \"order_id\": order.get(\"id\",\"\"),\n            \"order_status\": order_status,\n            \"close_timestamp\": \"\",\n            \"close_price\": 0.0,\n            \"pnl\": 0.0,\n        }\n        collection.data.insert(log)\n        print(\"✅ stub日志已写入：\", log)\n    finally:\n        client.close()",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "pct",
      ".",
      "tp",
      ")",
      "signal",
      "api",
      ":",
      "price",
      ",",
      "order",
      "sl",
      "\""
    ],
    "calls": [
      "calc_size",
      "calc_sl_tp",
      "close",
      "execute_signal",
      "get",
      "get_client",
      "get_latest_price",
      "in",
      "insert",
      "now",
      "place_order",
      "print",
      "str",
      "strftime"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/agent_stub.py",
    "startLine": 21,
    "endLine": 52,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:execute_signal"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Try:Try\n# Params: 无\n    try:\n        collection = client.collections.get(\"TradeLog\")\n        ts = datetime.now(timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\"\n\n        size = calc_size(capital, risk_pct, price)\n        sl, tp = calc_sl_tp(price, sl_pct, tp_pct)\n        order = {}\n        order_status = \"NOSIGNAL\"\n        if signal in (\"BUY\", \"SELL\"):\n            order = place_order(symbol, signal, size, \"MARKET\")\n            order_status = \"FILLED\"\n\n        log = {\n            \"timestamp\": ts,\n            \"symbol\": symbol,\n            \"price\": price,\n            \"signal\": signal,\n            \"size\": size,\n            \"sl\": sl,\n            \"tp\": tp,\n            \"strategy_name\": \"agent_stub\",\n            \"strategy_params\": str({\"risk_pct\": risk_pct, \"sl_pct\": sl_pct, \"tp_pct\": tp_pct}),\n            \"order_id\": order.get(\"id\",\"\"),\n            \"order_status\": order_status,\n            \"close_timestamp\": \"\",\n            \"close_price\": 0.0,\n            \"pnl\": 0.0,\n        }\n        collection.data.insert(log)\n        print(\"✅ stub日志已写入：\", log)\n    finally:\n        client.close()",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "pct",
      ".",
      "tp",
      ")",
      "api",
      "size",
      ":",
      "price",
      ",",
      "order",
      "sl",
      "\""
    ],
    "calls": [
      "calc_size",
      "calc_sl_tp",
      "close",
      "get",
      "in",
      "insert",
      "now",
      "place_order",
      "print",
      "str",
      "strftime"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/agent_stub.py",
    "startLine": 33,
    "endLine": 48,
    "signature": "Assign:Assign",
    "parentSignature": [
      "FunctionDef:execute_signal"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Assign:Assign\n# Params: 无\n        log = {\n            \"timestamp\": ts,\n            \"symbol\": symbol,\n            \"price\": price,\n            \"signal\": signal,\n            \"size\": size,\n            \"sl\": sl,\n            \"tp\": tp,\n            \"strategy_name\": \"agent_stub\",\n            \"strategy_params\": str({\"risk_pct\": risk_pct, \"sl_pct\": sl_pct, \"tp_pct\": tp_pct}),\n            \"order_id\": order.get(\"id\",\"\"),\n            \"order_status\": order_status,\n            \"close_timestamp\": \"\",\n            \"close_price\": 0.0,\n            \"pnl\": 0.0,\n        }",
    "tags": [
      "close",
      "name",
      "risk",
      "signal",
      "status",
      "size",
      "stub",
      "price",
      "strategy",
      "agent",
      "pct",
      "symbol",
      "timestamp",
      "order",
      "log"
    ],
    "calls": [
      "get",
      "str"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 19,
    "endLine": 98,
    "signature": "FunctionDef:agent_decide_and_execute",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 agent_decide_and_execute\n# Params: symbol:str=None, price:float | None=None, capital:float=None, risk_pct:float=None\ndef agent_decide_and_execute(\n    symbol: str,\n    price: float | None,\n    capital: float,\n    risk_pct: float,\n    *,\n    mode: Literal[\"random\", \"llm\", \"fix_buy\", \"fix_sell\"] = \"random\",\n    kappa: float = 1.5,\n    l_max: float = 100,\n    log_collection: str = \"TradeLog\",\n) -> None:\n    # 0. 价格校验\n    if price is None:\n        print(\"⚠️  无法获取实时价格，本轮跳过\")\n        return\n\n    # 1. AI / 随机 / 固定信号\n    prompt = f\"当前 {symbol} 价格 {price:.4f}，请判断：买/卖/观望？\"\n    if mode == \"fix_sell\":\n        signal = \"SELL\"\n    elif mode == \"fix_buy\":\n        signal = \"BUY\"\n    elif mode == \"random\":\n        signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))\n    else:  # llm\n        try:\n            import openai\n            openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n            r = openai.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=[{\"role\":\"user\",\"content\":prompt}],\n                timeout=6\n            )\n            signal = r.choices[0].message.content.strip().upper()\n            if signal not in (\"BUY\", \"SELL\", \"HOLD\"):\n                signal = \"HOLD\"\n        except Exception as e:\n            print(\"⚠️  LLM 调用失败，改用随机信号:\", e)\n            signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))\n\n    # 2. 只在“真实决策”情况下记录日志：HOLD 不记录任何日志\n    if signal == \"HOLD\":\n        return  # 不写日志，不下单，直接跳过，避免噪声污染因果链\n\n    # 3. 取合约规格\n    spec = get_instrument_spec(symbol)   # {ct_val,min_sz,lot_sz,period_sec}\n    ct_val, min_sz, lot_sz = spec[\"ct_val\"], spec[\"min_sz\"], spec[\"lot_sz\"]\n\n    # 4. 动态杠杆 & 止损\n    kline = spec[\"recent_prices\"]        # Pandas Series；需由 get_instrument_spec 带回\n    sigma = compute_volatility(kline, spec[\"period_sec\"])\n    leverage = max(1, min(kappa / sigma if sigma else 1, l_max))\n    leverage = float(leverage)   # 让 JSON 不带 np.float64\n\n    atr   = compute_atr(spec[\"recent_high\"], spec[\"recent_low\"], kline)\n    stop  = calc_initial_sl(price, atr, signal)\n    stop_dist = abs(price - stop)\n\n    # 极端值保护，只记录因果链关键分支\n    if sigma == 0 or atr == 0 or stop_dist == 0:\n        print(f\"⚠️ ATR或σ或止损距离为0，本轮跳过。sigma={sigma}, atr={atr}, stop_dist={stop_dist}\")\n        _write_log(prompt, symbol, price, signal, 0, stop, leverage,\n                   _extra(capital, risk_pct, leverage, sigma, atr, 0, 0, ct_val,\n                          min_sz, lot_sz, stop_dist),\n                   \"EXTREME_ZERO\", log_collection)\n        return\n\n    # 5. 计算张数\n    size_raw = (capital * risk_pct) / (stop_dist * ct_val)\n    size = calc_size(\n        capital       = capital,\n        risk_pct      = risk_pct,\n        entry_price   = price,\n        stop_price    = stop,\n        ct_val        = ct_val,\n        min_sz        = min_sz,\n        lot_sz        = lot_sz,\n    )\n    if size == 0:\n        print(\"size < minSz，放弃本单\")",
    "tags": [
      "",
      "=",
      "(",
      "_",
      "]",
      ".",
      "error_handling",
      ")",
      "#",
      "sz",
      ":",
      "stop",
      "[",
      "api",
      ",",
      "\""
    ],
    "calls": [
      "_extra",
      "_write_log",
      "abs",
      "agent_decide_and_execute",
      "calc_initial_sl",
      "calc_size",
      "choice",
      "compute_atr",
      "compute_volatility",
      "create",
      "float",
      "get_instrument_spec",
      "getenv",
      "in",
      "max",
      "min",
      "print",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 99,
    "endLine": 121,
    "signature": "FunctionDef:agent_decide_and_execute",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 agent_decide_and_execute\n# Params: symbol:str=None, price:float | None=None, capital:float=None, risk_pct:float=None\n        _write_log(prompt, symbol, price, signal, 0, stop, 0,\n                   _extra(capital, risk_pct, leverage, sigma, atr, size_raw, size, ct_val,\n                          min_sz, lot_sz, stop_dist),\n                   \"SIZE_TOO_SMALL\", log_collection)\n        return\n\n    # 6. 下单\n    order = place_order(\n        symbol   = symbol,\n        side     = signal,\n        qty      = size,\n        leverage = leverage,\n        td_mode  = \"isolated\",\n        min_sz   = min_sz,\n        lot_sz   = lot_sz,\n    )\n    status = order.get(\"status\")\n\n    # 7. 写日志（只在真实有意义决策分支）\n    _write_log(prompt, symbol, price, signal, size, stop, leverage,\n               _extra(capital, risk_pct, leverage, sigma, atr, size_raw, size, ct_val,\n                      min_sz, lot_sz, stop_dist),\n               status, log_collection, order_id=order.get(\"id\",\"\"))",
    "tags": [
      "",
      "=",
      "(",
      "_",
      "leverage",
      "stop",
      ")",
      "api",
      "sz",
      "size",
      "min",
      ",",
      "symbol",
      "order",
      "log",
      "\""
    ],
    "calls": [
      "_extra",
      "_write_log",
      "get",
      "place_order"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 136,
    "endLine": 149,
    "signature": "FunctionDef:_write_log",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 _write_log\n# Params: prompt:None=None, symbol:None=None, price:None=None, signal:None=None, size:None=None, stop:None=None, lev:None=None, extra:None=None, status:None=None, log_collection:None=None, order_id:None=''\ndef _write_log(prompt, symbol, price, signal, size, stop, lev, extra, status,\n               log_collection, order_id=\"\") -> None:\n    log = {\n        \"timestamp\": int(time.time() * 1000),  # 当前毫秒级 Unix 时间戳\n        \"symbol\": symbol, \"price\": price, \"signal\": signal,\n        \"size\": size, \"stop\": stop, \"leverage\": lev,\n        \"status\": status, \"order_id\": order_id,\n        \"prompt\": prompt, \"extra\": json.dumps(extra, ensure_ascii=False),\n    }\n    try:\n        cli = get_client(); cli.collections.get(log_collection).data.insert(log); cli.close()\n    except Exception as e:\n        print(\"⚠️ 写入日志失败:\", e)\n    print(\"✅ 因果日志:\", log)",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "prompt",
      ".",
      "error_handling",
      ")",
      "signal",
      ":",
      "price",
      ",",
      "symbol",
      "log",
      "\""
    ],
    "calls": [
      "_write_log",
      "close",
      "dumps",
      "get",
      "get_client",
      "insert",
      "int",
      "print",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 37,
    "endLine": 57,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:agent_decide_and_execute"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: If:If\n# Params: 无\n    if mode == \"fix_sell\":\n        signal = \"SELL\"\n    elif mode == \"fix_buy\":\n        signal = \"BUY\"\n    elif mode == \"random\":\n        signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))\n    else:  # llm\n        try:\n            import openai\n            openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n            r = openai.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=[{\"role\":\"user\",\"content\":prompt}],\n                timeout=6\n            )\n            signal = r.choices[0].message.content.strip().upper()\n            if signal not in (\"BUY\", \"SELL\", \"HOLD\"):\n                signal = \"HOLD\"\n        except Exception as e:\n            print(\"⚠️  LLM 调用失败，改用随机信号:\", e)\n            signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))",
    "tags": [
      "",
      "=",
      "(",
      "openai",
      "_",
      ".",
      "error_handling",
      ")",
      "signal",
      "api",
      ":",
      "sell",
      ",",
      "hold",
      "buy",
      "\""
    ],
    "calls": [
      "choice",
      "create",
      "getenv",
      "in",
      "print",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 39,
    "endLine": 57,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:agent_decide_and_execute"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: If:If\n# Params: 无\n    elif mode == \"fix_buy\":\n        signal = \"BUY\"\n    elif mode == \"random\":\n        signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))\n    else:  # llm\n        try:\n            import openai\n            openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n            r = openai.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=[{\"role\":\"user\",\"content\":prompt}],\n                timeout=6\n            )\n            signal = r.choices[0].message.content.strip().upper()\n            if signal not in (\"BUY\", \"SELL\", \"HOLD\"):\n                signal = \"HOLD\"\n        except Exception as e:\n            print(\"⚠️  LLM 调用失败，改用随机信号:\", e)\n            signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))",
    "tags": [
      "",
      "=",
      "(",
      "openai",
      "_",
      "random",
      ".",
      "error_handling",
      ")",
      "signal",
      "api",
      ":",
      ",",
      "hold",
      "buy",
      "\""
    ],
    "calls": [
      "choice",
      "create",
      "getenv",
      "in",
      "print",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 41,
    "endLine": 57,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:agent_decide_and_execute"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: If:If\n# Params: 无\n    elif mode == \"random\":\n        signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))\n    else:  # llm\n        try:\n            import openai\n            openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n            r = openai.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=[{\"role\":\"user\",\"content\":prompt}],\n                timeout=6\n            )\n            signal = r.choices[0].message.content.strip().upper()\n            if signal not in (\"BUY\", \"SELL\", \"HOLD\"):\n                signal = \"HOLD\"\n        except Exception as e:\n            print(\"⚠️  LLM 调用失败，改用随机信号:\", e)\n            signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))",
    "tags": [
      "",
      "=",
      "(",
      "openai",
      "_",
      "random",
      ".",
      "error_handling",
      ")",
      "signal",
      "api",
      ":",
      ",",
      "hold",
      "buy",
      "\""
    ],
    "calls": [
      "choice",
      "create",
      "getenv",
      "in",
      "print",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/llm_agent.py",
    "startLine": 44,
    "endLine": 57,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:agent_decide_and_execute"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Try:Try\n# Params: 无\n        try:\n            import openai\n            openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n            r = openai.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=[{\"role\":\"user\",\"content\":prompt}],\n                timeout=6\n            )\n            signal = r.choices[0].message.content.strip().upper()\n            if signal not in (\"BUY\", \"SELL\", \"HOLD\"):\n                signal = \"HOLD\"\n        except Exception as e:\n            print(\"⚠️  LLM 调用失败，改用随机信号:\", e)\n            signal = random.choice((\"BUY\", \"SELL\", \"HOLD\"))",
    "tags": [
      "",
      "=",
      "(",
      "openai",
      "key",
      "_",
      ".",
      "error_handling",
      ")",
      "signal",
      "api",
      ":",
      ",",
      "hold",
      "\""
    ],
    "calls": [
      "choice",
      "create",
      "getenv",
      "in",
      "print",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/position_guard.py",
    "startLine": 6,
    "endLine": 71,
    "signature": "ClassDef:PositionGuard",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 类 PositionGuard\n# Params: 无\nclass PositionGuard:\n    \"\"\"\n    持仓方向本地缓存（单向持仓）。\n    * 线程安全 + 过期自动失效\n    \"\"\"\n    _instance: Optional['PositionGuard'] = None\n    _lock     = asyncio.Lock()\n\n    def __new__(cls, *a, **k):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    # -------- #\n    def __init__(\n        self,\n        *,\n        cache_file: str = \"/tmp/position_guard.json\",\n        expire_sec: float = 3600.0,\n        logger: logging.Logger | None = None,\n    ) -> None:\n        if hasattr(self, \"_init\"):  # 保证单例只初始化一次\n            return\n        self._init = True\n        self.file = cache_file\n        self.expire = expire_sec\n        self.log = logger or logging.getLogger(\"PositionGuard\")\n        self.state: dict[str, str | float] = {\"direction\": None, \"ts\": 0.0}\n        self._load()\n\n    # -------- public -------- #\n    async def get(self) -> Signal:\n        async with self._lock:\n            self._check_expire()\n            return self.state[\"direction\"]  # type: ignore\n\n    async def update(self, direction: Signal) -> None:\n        async with self._lock:\n            self.state.update(direction=direction, ts=time.time())\n            self._save()\n\n    async def reset(self) -> None:\n        await self.update(None)\n\n    # -------- private -------- #\n    def _check_expire(self) -> None:\n        if self.state[\"direction\"] and time.time() - self.state[\"ts\"] > self.expire:\n            self.log.info(\"Position expired, auto-reset.\")\n            self.state.update(direction=None, ts=0.0)\n            self._save()\n\n    def _load(self) -> None:\n        try:\n            if os.path.exists(self.file):\n                with open(self.file, \"r\") as f:\n                    self.state = json.load(f)\n        except Exception as e:\n            self.log.warning(\"load cache failed: %s, reset.\", e)\n            self.state = {\"direction\": None, \"ts\": 0.0}\n\n    def _save(self) -> None:\n        try:\n            with open(self.file, \"w\") as f:\n                json.dump(self.state, f)\n        except Exception as e:\n            self.log.warning(\"save cache failed: %s\", e)",
    "tags": [
      "",
      "(",
      "=",
      "._",
      "update_logic",
      "_",
      "none",
      ".",
      "error_handling",
      ")",
      ":",
      ".__",
      "self",
      ",",
      "\"",
      "__"
    ],
    "calls": [
      "Lock",
      "__init__",
      "__new__",
      "_check_expire",
      "_load",
      "_save",
      "dump",
      "exists",
      "get",
      "getLogger",
      "hasattr",
      "info",
      "load",
      "open",
      "reset",
      "super",
      "time",
      "update",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "持仓方向本地缓存（单向持仓）。\n    * 线程安全 + 过期自动失效"
  },
  {
    "filePath": "/root/kk/src/agent/position_guard.py",
    "startLine": 20,
    "endLine": 34,
    "signature": "FunctionDef:__init__",
    "parentSignature": [
      "ClassDef:PositionGuard"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 __init__\n# Params: self:None=None\n    def __init__(\n        self,\n        *,\n        cache_file: str = \"/tmp/position_guard.json\",\n        expire_sec: float = 3600.0,\n        logger: logging.Logger | None = None,\n    ) -> None:\n        if hasattr(self, \"_init\"):  # 保证单例只初始化一次\n            return\n        self._init = True\n        self.file = cache_file\n        self.expire = expire_sec\n        self.log = logger or logging.getLogger(\"PositionGuard\")\n        self.state: dict[str, str | float] = {\"direction\": None, \"ts\": 0.0}\n        self._load()",
    "tags": [
      "",
      "=",
      "(",
      "._",
      "_",
      "none",
      ".",
      ")",
      ":",
      "file",
      "self",
      ",",
      "__",
      "init",
      "\""
    ],
    "calls": [
      "__init__",
      "_load",
      "getLogger",
      "hasattr"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/price_consumer.py",
    "startLine": 7,
    "endLine": 60,
    "signature": "ClassDef:PriceConsumer",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 类 PriceConsumer\n# Params: 无\nclass PriceConsumer:\n    \"\"\"\n    高频行情队列 -> 降频触发。聚合窗口内只取最后一价。\n    \"\"\"\n    def __init__(\n        self,\n        queue: asyncio.Queue[Number],\n        callback: Callable[[Number], Awaitable[None]],\n        *,\n        pct_trigger: float = 0.003,\n        agg_window: float = 1.0,\n        logger: Logger | None = None,\n    ) -> None:\n        self.q = queue\n        self.cb = callback\n        self.pct_trigger = pct_trigger\n        self.agg_window = agg_window\n        self._last_emit_price: Number | None = None\n        self._last_emit_ts:  float = 0.0\n        self.log = logger or logging.getLogger(\"PriceConsumer\")\n\n    async def run(self) -> None:\n        window_prices: list[Number] = []\n        next_tick = time.time() + self.agg_window\n\n        while True:\n            try:\n                timeout = max(0.0, next_tick - time.time())\n                price: Number = await asyncio.wait_for(self.q.get(), timeout=timeout)\n                window_prices.append(price)\n                # 价格突变立即 emit\n                if self._should_emit(price):\n                    await self._emit(price)\n                    window_prices.clear()\n                    next_tick = time.time() + self.agg_window\n            except asyncio.TimeoutError:\n                # 窗口到期 emit\n                if window_prices:\n                    await self._emit(window_prices[-1])\n                    window_prices.clear()\n                next_tick = time.time() + self.agg_window\n            except Exception as e:\n                self.log.exception(\"PriceConsumer error: %s\", e)\n                await asyncio.sleep(1)\n\n    def _should_emit(self, price: Number) -> bool:\n        if self._last_emit_price is None:\n            return True\n        return abs(price - self._last_emit_price) / self._last_emit_price >= self.pct_trigger\n\n    async def _emit(self, price: Number) -> None:\n        await self.cb(price)\n        self._last_emit_price = price\n        self._last_emit_ts   = time.time()",
    "tags": [
      "",
      "(",
      "=",
      "._",
      "emit",
      "_",
      "window",
      ".",
      "error_handling",
      ")",
      ":",
      "price",
      "self",
      ",",
      "__"
    ],
    "calls": [
      "__init__",
      "_emit",
      "_should_emit",
      "abs",
      "append",
      "cb",
      "clear",
      "exception",
      "get",
      "getLogger",
      "max",
      "run",
      "sleep",
      "time",
      "wait_for"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "高频行情队列 -> 降频触发。聚合窗口内只取最后一价。"
  },
  {
    "filePath": "/root/kk/src/agent/price_consumer.py",
    "startLine": 11,
    "endLine": 26,
    "signature": "FunctionDef:__init__",
    "parentSignature": [
      "ClassDef:PriceConsumer"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 __init__\n# Params: self:None=None, queue:asyncio.Queue[Number]=None, callback:Callable[[Number], Awaitable[None]]=None\n    def __init__(\n        self,\n        queue: asyncio.Queue[Number],\n        callback: Callable[[Number], Awaitable[None]],\n        *,\n        pct_trigger: float = 0.003,\n        agg_window: float = 1.0,\n        logger: Logger | None = None,\n    ) -> None:\n        self.q = queue\n        self.cb = callback\n        self.pct_trigger = pct_trigger\n        self.agg_window = agg_window\n        self._last_emit_price: Number | None = None\n        self._last_emit_ts:  float = 0.0\n        self.log = logger or logging.getLogger(\"PriceConsumer\")",
    "tags": [
      "number",
      "emit",
      "asyncio",
      "queue",
      "last",
      "window",
      "none",
      "float",
      "logger",
      "trigger",
      "self",
      "pct",
      "agg",
      "callback",
      "init"
    ],
    "calls": [
      "__init__",
      "getLogger"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/price_consumer.py",
    "startLine": 28,
    "endLine": 50,
    "signature": "AsyncFunctionDef:run",
    "parentSignature": [
      "ClassDef:PriceConsumer"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Async函数 run\n# Params: self:None=None\n    async def run(self) -> None:\n        window_prices: list[Number] = []\n        next_tick = time.time() + self.agg_window\n\n        while True:\n            try:\n                timeout = max(0.0, next_tick - time.time())\n                price: Number = await asyncio.wait_for(self.q.get(), timeout=timeout)\n                window_prices.append(price)\n                # 价格突变立即 emit\n                if self._should_emit(price):\n                    await self._emit(price)\n                    window_prices.clear()\n                    next_tick = time.time() + self.agg_window\n            except asyncio.TimeoutError:\n                # 窗口到期 emit\n                if window_prices:\n                    await self._emit(window_prices[-1])\n                    window_prices.clear()\n                next_tick = time.time() + self.agg_window\n            except Exception as e:\n                self.log.exception(\"PriceConsumer error: %s\", e)\n                await asyncio.sleep(1)",
    "tags": [
      "",
      "(",
      "time",
      "._",
      "=",
      "prices",
      "_",
      "emit",
      "window",
      ".",
      "error_handling",
      ")",
      ":",
      "self",
      "next"
    ],
    "calls": [
      "_emit",
      "_should_emit",
      "append",
      "clear",
      "exception",
      "get",
      "max",
      "run",
      "sleep",
      "time",
      "wait_for"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/price_consumer.py",
    "startLine": 32,
    "endLine": 50,
    "signature": "While:While",
    "parentSignature": [
      "ClassDef:PriceConsumer",
      "AsyncFunctionDef:run"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: While:While\n# Params: 无\n        while True:\n            try:\n                timeout = max(0.0, next_tick - time.time())\n                price: Number = await asyncio.wait_for(self.q.get(), timeout=timeout)\n                window_prices.append(price)\n                # 价格突变立即 emit\n                if self._should_emit(price):\n                    await self._emit(price)\n                    window_prices.clear()\n                    next_tick = time.time() + self.agg_window\n            except asyncio.TimeoutError:\n                # 窗口到期 emit\n                if window_prices:\n                    await self._emit(window_prices[-1])\n                    window_prices.clear()\n                next_tick = time.time() + self.agg_window\n            except Exception as e:\n                self.log.exception(\"PriceConsumer error: %s\", e)\n                await asyncio.sleep(1)",
    "tags": [
      "",
      "(",
      "time",
      "._",
      "=",
      "prices",
      "_",
      "emit",
      "window",
      ".",
      "error_handling",
      ")",
      ":",
      "price",
      "self"
    ],
    "calls": [
      "_emit",
      "_should_emit",
      "append",
      "clear",
      "exception",
      "get",
      "max",
      "sleep",
      "time",
      "wait_for"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/price_consumer.py",
    "startLine": 33,
    "endLine": 50,
    "signature": "Try:Try",
    "parentSignature": [
      "ClassDef:PriceConsumer",
      "AsyncFunctionDef:run"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: Try:Try\n# Params: 无\n            try:\n                timeout = max(0.0, next_tick - time.time())\n                price: Number = await asyncio.wait_for(self.q.get(), timeout=timeout)\n                window_prices.append(price)\n                # 价格突变立即 emit\n                if self._should_emit(price):\n                    await self._emit(price)\n                    window_prices.clear()\n                    next_tick = time.time() + self.agg_window\n            except asyncio.TimeoutError:\n                # 窗口到期 emit\n                if window_prices:\n                    await self._emit(window_prices[-1])\n                    window_prices.clear()\n                next_tick = time.time() + self.agg_window\n            except Exception as e:\n                self.log.exception(\"PriceConsumer error: %s\", e)\n                await asyncio.sleep(1)",
    "tags": [
      "",
      "(",
      "time",
      "._",
      "=",
      "prices",
      "_",
      "emit",
      "window",
      ".",
      "error_handling",
      ")",
      ":",
      "price",
      "self"
    ],
    "calls": [
      "_emit",
      "_should_emit",
      "append",
      "clear",
      "exception",
      "get",
      "max",
      "sleep",
      "time",
      "wait_for"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/agent/signal_filter.py",
    "startLine": 6,
    "endLine": 32,
    "signature": "ClassDef:SignalFilter",
    "parentSignature": [],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 类 SignalFilter\n# Params: 无\nclass SignalFilter:\n    \"\"\"\n    连续同向信号/节流滤波。\n    \"\"\"\n    def __init__(self, *, n_same: int = 2, throttle: float = 30.0) -> None:\n        self.n_same = n_same\n        self.throttle = throttle\n        self._buf: Deque[Signal] = collections.deque(maxlen=n_same)\n        self._last_emit_ts: float = 0.0\n\n    def push(self, sig: Signal) -> Signal | None:\n        now = time.time()\n        if now - self._last_emit_ts < self.throttle:\n            return None  # 节流\n        if sig == \"HOLD\":\n            self._buf.clear()\n            return None\n        self._buf.append(sig)\n        if len(self._buf) == self.n_same and len(set(self._buf)) == 1:\n            self._buf.clear()\n            self._last_emit_ts = now\n            return sig\n        return None\n\n    def reset(self) -> None:\n        self._buf.clear()\n        self._last_emit_ts = 0.0",
    "tags": [
      "",
      "=",
      "(",
      "._",
      "n",
      "_",
      "none",
      "same",
      ".",
      ")",
      ":",
      "self",
      "\"",
      "buf",
      "__"
    ],
    "calls": [
      "__init__",
      "append",
      "clear",
      "deque",
      "len",
      "push",
      "reset",
      "set",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "连续同向信号/节流滤波。"
  },
  {
    "filePath": "/root/kk/src/agent/signal_filter.py",
    "startLine": 16,
    "endLine": 28,
    "signature": "FunctionDef:push",
    "parentSignature": [
      "ClassDef:SignalFilter"
    ],
    "moduleName": "agent",
    "importPath": "/root/kk/src/agent",
    "content": "# Summary: 函数 push\n# Params: self:None=None, sig:Signal=None\n    def push(self, sig: Signal) -> Signal | None:\n        now = time.time()\n        if now - self._last_emit_ts < self.throttle:\n            return None  # 节流\n        if sig == \"HOLD\":\n            self._buf.clear()\n            return None\n        self._buf.append(sig)\n        if len(self._buf) == self.n_same and len(set(self._buf)) == 1:\n            self._buf.clear()\n            self._last_emit_ts = now\n            return sig\n        return None",
    "tags": [
      "",
      "(",
      "=",
      "._",
      "_",
      "-",
      "sig",
      "none",
      ".",
      ")",
      "signal",
      ":",
      "now",
      "self",
      "buf"
    ],
    "calls": [
      "append",
      "clear",
      "len",
      "push",
      "set",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/event_classifier.py",
    "startLine": 3,
    "endLine": 33,
    "signature": "ClassDef:EventClassifier",
    "parentSignature": [],
    "moduleName": "src",
    "importPath": "/root/kk/src",
    "content": "# Summary: 类 EventClassifier\n# Params: 无\nclass EventClassifier:\n    \"\"\"窗口内价格与量能特征 → bool 显著事件\"\"\"\n    def __init__(self,\n        price_window=60, vol_window=30,\n        pct_th=0.004, accel_th=2.0, vol_th=3.0):\n        self.prices = collections.deque(maxlen=price_window)\n        self.vols   = collections.deque(maxlen=vol_window)\n        self.pct_th      = pct_th\n        self.accel_th    = accel_th\n        self.vol_th_ratio= vol_th\n        self.last_ts = 0\n\n    def push(self, price: float, volume: float = 1.0) -> bool:\n        now = time.time()\n        self.prices.append(price)\n        self.vols.append(volume)\n        # 1) 价差\n        if len(self.prices) >= 2:\n            pct = abs(price - self.prices[-2]) / self.prices[-2]\n            if pct >= self.pct_th: return True\n        # 2) 加速度\n        if len(self.prices) >= 3:\n            accel = (self.prices[-1]-self.prices[-2])-(self.prices[-2]-self.prices[-3])\n            mu = statistics.mean(abs(self.prices[i]-self.prices[i-1]) for i in range(1,len(self.prices)))\n            if mu and abs(accel)/mu >= self.accel_th: return True\n        # 3) 量能\n        if len(self.vols) == self.vols.maxlen:\n            if volume / (sum(self.vols)/len(self.vols)) >= self.vol_th_ratio:\n                return True\n        # fallback\n        return False",
    "tags": [
      "",
      "=",
      "(",
      "prices",
      "th",
      "_",
      "-",
      "]",
      ".",
      "[",
      ")",
      ":",
      "self",
      ",",
      "__"
    ],
    "calls": [
      "__init__",
      "abs",
      "append",
      "deque",
      "len",
      "mean",
      "push",
      "range",
      "sum",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "窗口内价格与量能特征 → bool 显著事件"
  },
  {
    "filePath": "/root/kk/src/event_classifier.py",
    "startLine": 15,
    "endLine": 33,
    "signature": "FunctionDef:push",
    "parentSignature": [
      "ClassDef:EventClassifier"
    ],
    "moduleName": "src",
    "importPath": "/root/kk/src",
    "content": "# Summary: 函数 push\n# Params: self:None=None, price:float=None, volume:float=1.0\n    def push(self, price: float, volume: float = 1.0) -> bool:\n        now = time.time()\n        self.prices.append(price)\n        self.vols.append(volume)\n        # 1) 价差\n        if len(self.prices) >= 2:\n            pct = abs(price - self.prices[-2]) / self.prices[-2]\n            if pct >= self.pct_th: return True\n        # 2) 加速度\n        if len(self.prices) >= 3:\n            accel = (self.prices[-1]-self.prices[-2])-(self.prices[-2]-self.prices[-3])\n            mu = statistics.mean(abs(self.prices[i]-self.prices[i-1]) for i in range(1,len(self.prices)))\n            if mu and abs(accel)/mu >= self.accel_th: return True\n        # 3) 量能\n        if len(self.vols) == self.vols.maxlen:\n            if volume / (sum(self.vols)/len(self.vols)) >= self.vol_th_ratio:\n                return True\n        # fallback\n        return False",
    "tags": [
      "",
      "(",
      "=",
      "prices",
      "2",
      "vols",
      "_",
      "-",
      "]",
      ".",
      "[",
      ")",
      ":",
      "self",
      ">"
    ],
    "calls": [
      "abs",
      "append",
      "len",
      "mean",
      "push",
      "range",
      "sum",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/llm_local_client.py",
    "startLine": 10,
    "endLine": 26,
    "signature": "FunctionDef:_call_ollama",
    "parentSignature": [],
    "moduleName": "src",
    "importPath": "/root/kk/src",
    "content": "# Summary: 函数 _call_ollama\n# Params: prompt:str=None, temperature:None=0.2, read_timeout:None=300\ndef _call_ollama(prompt: str, temperature=0.2, read_timeout=300):\n    payload = {\n        \"model\": MODEL,\n        \"prompt\": prompt,\n        \"temperature\": temperature,\n        \"stream\": False\n    }\n    t0 = time.time()\n    try:\n        # 10s 连接超时，300s 读取超时\n        r = requests.post(OLLAMA_URL, json=payload, timeout=(10, read_timeout))\n        r.raise_for_status()\n        resp = r.json().get(\"response\", \"ERR\")\n    except Exception as e:\n        logging.warning(\"Ollama timeout/err: %s\", e)\n        resp = \"ERR\"\n    return resp, time.time() - t0",
    "tags": [
      "",
      "(",
      "=",
      "timeout",
      "time",
      "_",
      "prompt",
      ".",
      "error_handling",
      ")",
      ":",
      "temperature",
      ",",
      "ollama",
      "\""
    ],
    "calls": [
      "_call_ollama",
      "get",
      "json",
      "post",
      "raise_for_status",
      "time",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/logging/schema.py",
    "startLine": 4,
    "endLine": 22,
    "signature": "Assign:Assign",
    "parentSignature": [],
    "moduleName": "logging",
    "importPath": "/root/kk/src/logging",
    "content": "# Summary: Assign:Assign\n# Params: 无\nTradeLogTemplate = {\n    \"timestamp\": str,\n    \"symbol\": str,\n    \"signal\": str,\n    \"price\": float,\n    \"strategy_name\": str,\n    \"strategy_params\": Dict[str, Any],\n    \"prompt\": str,\n    \"ai_response\": str,\n    \"order_id\": str,\n    \"size\": float,\n    \"sl\": float,\n    \"tp\": float,\n    \"order_status\": str,\n    \"close_timestamp\": str,\n    \"close_price\": float,\n    \"pnl\": float,\n    \"context\": str,\n}",
    "tags": [
      "close",
      "dict",
      "any",
      "prompt",
      "str",
      "name",
      "float",
      "tradelogtemplate",
      "signal",
      "strategy",
      "price",
      "params",
      "symbol",
      "timestamp",
      "order"
    ],
    "calls": [],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/optimizer.py",
    "startLine": 6,
    "endLine": 29,
    "signature": "FunctionDef:main",
    "parentSignature": [],
    "moduleName": "src",
    "importPath": "/root/kk/src",
    "content": "# Summary: 函数 main\n# Params: 无\ndef main():\n    client = get_client()\n    ensure_schema()\n\n    # 示例：参数优化，可以替换为自动扫描/AI推荐逻辑\n    # 这里暂用随机参数以便跑通自动化闭环\n    recommended = {\n        \"risk_pct\": round(random.uniform(0.005, 0.03), 4)\n        # 后续可扩展更多参数，如 sl_pct, tp_pct, threshold 等\n    }\n\n    entry = {\n        \"timestamp\": datetime.datetime.utcnow().isoformat() + \"Z\",\n        \"symbol\": \"ETH-USDT\",\n        \"strategy_name\": \"llm_basic\",\n        \"strategy_params\": json.dumps(recommended),\n        \"ai_response\": \"RECOMMEND\"\n    }\n\n    collection = client.collections.get(\"TradeLog\")\n    collection.data.insert(entry)\n\n    client.close()\n    print(\"✅ AI 参数推荐已写入\", recommended)",
    "tags": [
      "",
      "(",
      "=",
      "ai",
      "recommended",
      "_",
      "client",
      "参数",
      "pct",
      ".",
      "#",
      ")",
      ":",
      ",",
      "\""
    ],
    "calls": [
      "close",
      "dumps",
      "ensure_schema",
      "get",
      "get_client",
      "insert",
      "isoformat",
      "main",
      "print",
      "round",
      "uniform",
      "utcnow"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/risk/dynamic.py",
    "startLine": 8,
    "endLine": 25,
    "signature": "FunctionDef:build_trailing_sl_params",
    "parentSignature": [],
    "moduleName": "risk",
    "importPath": "/root/kk/src/risk",
    "content": "# Summary: 函数 build_trailing_sl_params\n# Params: side:Signal=None, entry_price:float=None, trail_sl_pct:float=None\ndef build_trailing_sl_params(\n    side: Signal,\n    entry_price: float,\n    trail_sl_pct: float,\n) -> dict:\n    \"\"\"\n    返回 OKX 原生 trailing-stop 所需字段：\n      - triggerPx    : 开仓价\n      - callbackRate : 百分比 (例 0.5% → \"0.5\")\n    \"\"\"\n    return {\n        \"triggerPx\"   : str(entry_price),\n        \"callbackRate\": f\"{trail_sl_pct*100:.3f}\",   # OKX 需字符串 %\n        \"algoOrdType\" : \"trailing_stop\",\n        \"side\"        : side.lower(),\n        \"tpTriggerPx\" : \"\",\n        \"slTriggerPx\" : \"\",\n    }",
    "tags": [
      "",
      "(",
      "entry",
      "_",
      "-",
      "float",
      ")",
      "trail",
      "trailing",
      ":",
      "side",
      "price",
      ",",
      "sl",
      "\""
    ],
    "calls": [
      "build_trailing_sl_params",
      "lower",
      "str"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "返回 OKX 原生 trailing-stop 所需字段：\n      - triggerPx    : 开仓价\n      - callbackRate : 百分比 (例 0.5% → \"0.5\")"
  },
  {
    "filePath": "/root/kk/src/risk/manager.py",
    "startLine": 13,
    "endLine": 40,
    "signature": "FunctionDef:calc_size",
    "parentSignature": [],
    "moduleName": "risk",
    "importPath": "/root/kk/src/risk",
    "content": "# Summary: 函数 calc_size\n# Params: capital:float=None, risk_pct:float=None, entry_price:float=None, stop_price:float=None\ndef calc_size(\n    capital: float,\n    risk_pct: float,\n    entry_price: float,\n    stop_price: float,\n    *,\n    ct_val: float,   # 1 张合约面值（ETH/USDT…）\n    min_sz: float,   # 交易所最小张数（允许小数）\n    lot_sz: float,   # 步进张数（允许小数）\n) -> float:\n    \"\"\"\n    根据风险单位 r 计算张数:\n        r = capital × risk_pct\n        contracts_raw = r / (|entry - stop| × ct_val)\n    取 floor 对齐 lot_sz；若 < min_sz ⇒ 返回 0（不下单）\n    \"\"\"\n    stop_dist = abs(entry_price - stop_price)\n    if stop_dist == 0:\n        return 0\n\n    # 理论张数\n    contracts = (capital * risk_pct) / (stop_dist * ct_val)\n\n    # 步进向下取整\n    contracts = math.floor(contracts / lot_sz) * lot_sz\n\n    # 最终张数，若不够最小张数则为 0\n    return contracts if contracts >= min_sz else 0",
    "tags": [
      "",
      "=",
      "(",
      "_",
      "contracts",
      "float",
      "stop",
      "#",
      ")",
      "sz",
      ":",
      "0",
      "api",
      ",",
      "张数",
      "\""
    ],
    "calls": [
      "abs",
      "calc_size",
      "floor"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "根据风险单位 r 计算张数:\n        r = capital × risk_pct\n        contracts_raw = r / (|entry - stop| × ct_val)\n    取 floor 对齐 lot_sz；若 < min_sz ⇒ 返回 0（不下单）"
  },
  {
    "filePath": "/root/kk/src/risk/manager.py",
    "startLine": 45,
    "endLine": 57,
    "signature": "FunctionDef:calc_sl_tp",
    "parentSignature": [],
    "moduleName": "risk",
    "importPath": "/root/kk/src/risk",
    "content": "# Summary: 函数 calc_sl_tp\n# Params: entry_price:float=None, sl_pct:float=None, tp_pct:float=None, side:Literal['BUY', 'SELL']='BUY'\ndef calc_sl_tp(\n    entry_price: float,\n    sl_pct: float,\n    tp_pct: float,\n    side: Literal[\"BUY\", \"SELL\"] = \"BUY\",\n) -> Tuple[float, float]:\n    if side == \"BUY\":\n        sl = entry_price * (1 - sl_pct)\n        tp = entry_price * (1 + tp_pct)\n    else:\n        sl = entry_price * (1 + sl_pct)\n        tp = entry_price * (1 - tp_pct)\n    return round(sl, 8), round(tp, 8)",
    "tags": [
      "literal",
      "round",
      "entry",
      "tuple",
      "calc",
      "float",
      "side",
      "price",
      "sell",
      "pct",
      "else",
      "buy"
    ],
    "calls": [
      "calc_sl_tp",
      "round"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/risk/trailing.py",
    "startLine": 14,
    "endLine": 57,
    "signature": "ClassDef:TrailingStop",
    "parentSignature": [],
    "moduleName": "risk",
    "importPath": "/root/kk/src/risk",
    "content": "# Summary: 类 TrailingStop\n# Params: 无\nclass TrailingStop:\n    def __init__(self) -> None:\n        self.side:   Optional[Side] = None     # 当前方向\n        self.best:   float | None    = None    # BUY→最高价；SELL→最低价\n        self.pct:    float           = 0.0     # 回撤百分比 (0-1)\n        self.active: bool            = False\n        self.log = logging.getLogger(\"TrailingSL\")\n\n    # ────────────────────────── API ──────────────────────────\n    def start(self, side: Side, entry: float, pct: float) -> None:\n        \"\"\"开启 / 覆盖\"\"\"\n        self.side, self.best, self.pct, self.active = side, entry, pct, True\n        self.log.info(\"⛓️  Trailing-SL start %s entry=%.4f pct=%.2f%%\",\n                      side, entry, pct * 100)\n\n    def cancel(self) -> None:\n        if self.active:\n            self.log.info(\"✂️  Trailing-SL cancel\")\n        self.active = False\n\n    def update(self, price: float) -> bool:\n        \"\"\"推入最新价；触发回撤则返回 True\"\"\"\n        if not self.active:\n            return False\n\n        # 1) 刷新极值\n        if self.side == \"BUY\":\n            if price > self.best:\n                self.best = price\n        else:                                # SELL\n            if price < self.best:\n                self.best = price\n\n        # 2) 计算回撤百分比\n        drawdown = ((self.best - price) / self.best\n                    if self.side == \"BUY\"\n                    else (price - self.best) / self.best)\n\n        if drawdown >= self.pct:\n            self.log.info(\"🚨 Trailing-SL hit! best=%.4f now=%.4f dd=%.2f%%\",\n                          self.best, price, drawdown * 100)\n            self.active = False\n            return True\n        return False",
    "tags": [
      "",
      "=",
      "(",
      "update_logic",
      "─",
      "-",
      ".",
      ")",
      "api",
      ":",
      "side",
      "price",
      "self",
      ",",
      "\"",
      "best",
      "__"
    ],
    "calls": [
      "__init__",
      "cancel",
      "else",
      "getLogger",
      "info",
      "start",
      "update"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "开启 / 覆盖"
  },
  {
    "filePath": "/root/kk/src/risk/trailing.py",
    "startLine": 34,
    "endLine": 57,
    "signature": "FunctionDef:update",
    "parentSignature": [
      "ClassDef:TrailingStop"
    ],
    "moduleName": "risk",
    "importPath": "/root/kk/src/risk",
    "content": "# Summary: 函数 update\n# Params: self:None=None, price:float=None\n    def update(self, price: float) -> bool:\n        \"\"\"推入最新价；触发回撤则返回 True\"\"\"\n        if not self.active:\n            return False\n\n        # 1) 刷新极值\n        if self.side == \"BUY\":\n            if price > self.best:\n                self.best = price\n        else:                                # SELL\n            if price < self.best:\n                self.best = price\n\n        # 2) 计算回撤百分比\n        drawdown = ((self.best - price) / self.best\n                    if self.side == \"BUY\"\n                    else (price - self.best) / self.best)\n\n        if drawdown >= self.pct:\n            self.log.info(\"🚨 Trailing-SL hit! best=%.4f now=%.4f dd=%.2f%%\",\n                          self.best, price, drawdown * 100)\n            self.active = False\n            return True\n        return False",
    "tags": [
      "",
      "=",
      "(",
      "update_logic",
      "-",
      ".",
      ",",
      ")",
      "#",
      ":",
      "price",
      "self",
      "best",
      ">",
      "false",
      "\""
    ],
    "calls": [
      "else",
      "info",
      "update"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "推入最新价；触发回撤则返回 True"
  },
  {
    "filePath": "/root/kk/src/storage/ensure_schema.py",
    "startLine": 8,
    "endLine": 28,
    "signature": "Assign:Assign",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: Assign:Assign\n# Params: 无\n_SCHEMA = {\n  \"class\": \"TradeLog\",\n  \"description\": \"策略交易与因果日志\",\n  \"properties\": [\n    {\"name\": \"timestamp\",           \"dataType\": [\"number\"]},\n    {\"name\": \"symbol\",              \"dataType\": [\"text\"]},\n    {\"name\": \"signal\",              \"dataType\": [\"text\"]},\n    {\"name\": \"price\",               \"dataType\": [\"number\"]},\n    {\"name\": \"size\",                \"dataType\": [\"number\"]},\n    {\"name\": \"leverage\",            \"dataType\": [\"number\"]},\n    {\"name\": \"order_id\",            \"dataType\": [\"text\"]},\n    {\"name\": \"status\",              \"dataType\": [\"text\"]},\n    {\"name\": \"prompt\",              \"dataType\": [\"text\"]},\n    {\"name\": \"extra\",               \"dataType\": [\"text\"]},\n    {\"name\": \"pnl_realized\",        \"dataType\": [\"number\"]},\n    {\"name\": \"equity\",              \"dataType\": [\"number\"]},\n    {\"name\": \"trail_sl_pct\",        \"dataType\": [\"number\"]},\n    {\"name\": \"trail_sl_price_init\",\"dataType\": [\"number\"]},\n    {\"name\": \"trail_sl_hit\",        \"dataType\": [\"text\"]}\n  ]\n}",
    "tags": [
      "",
      "number",
      "_",
      "datatype",
      "]",
      "name",
      "[",
      "trail",
      ":",
      "{",
      "text",
      ",",
      "}",
      "sl",
      "\""
    ],
    "calls": [],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/ensure_schema.py",
    "startLine": 64,
    "endLine": 81,
    "signature": "FunctionDef:ensure_schema",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: 函数 ensure_schema\n# Params: 无\ndef ensure_schema():\n    try:\n        schema = get_schema()\n        classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n        if \"TradeLog\" not in classes:\n            create_class()\n        else:\n            existing = {\n                p[\"name\"]\n                for c in schema[\"classes\"]\n                if c[\"class\"] == \"TradeLog\"\n                for p in c.get(\"properties\", [])\n            }\n            for prop in _SCHEMA[\"properties\"]:\n                if prop[\"name\"] not in existing:\n                    add_property(prop)\n    except Exception as e:\n        logging.warning(f\"Weaviate schema ensure failed: {e}\")",
    "tags": [
      "create",
      "add",
      "get",
      "prop",
      "name",
      "error_handling",
      "ensure",
      "properties",
      "try",
      "existing",
      "else",
      "tradelog",
      "schema",
      "classes",
      "not"
    ],
    "calls": [
      "add_property",
      "create_class",
      "ensure_schema",
      "get",
      "get_schema",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/ensure_schema.py",
    "startLine": 65,
    "endLine": 81,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:ensure_schema"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: Try:Try\n# Params: 无\n    try:\n        schema = get_schema()\n        classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n        if \"TradeLog\" not in classes:\n            create_class()\n        else:\n            existing = {\n                p[\"name\"]\n                for c in schema[\"classes\"]\n                if c[\"class\"] == \"TradeLog\"\n                for p in c.get(\"properties\", [])\n            }\n            for prop in _SCHEMA[\"properties\"]:\n                if prop[\"name\"] not in existing:\n                    add_property(prop)\n    except Exception as e:\n        logging.warning(f\"Weaviate schema ensure failed: {e}\")",
    "tags": [
      "create",
      "property",
      "add",
      "get",
      "prop",
      "name",
      "error_handling",
      "properties",
      "try",
      "existing",
      "else",
      "tradelog",
      "schema",
      "classes",
      "not"
    ],
    "calls": [
      "add_property",
      "create_class",
      "get",
      "get_schema",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/ensure_schema.py",
    "startLine": 68,
    "endLine": 79,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:ensure_schema"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: If:If\n# Params: 无\n        if \"TradeLog\" not in classes:\n            create_class()\n        else:\n            existing = {\n                p[\"name\"]\n                for c in schema[\"classes\"]\n                if c[\"class\"] == \"TradeLog\"\n                for p in c.get(\"properties\", [])\n            }\n            for prop in _SCHEMA[\"properties\"]:\n                if prop[\"name\"] not in existing:\n                    add_property(prop)",
    "tags": [
      "create",
      "property",
      "add",
      "get",
      "prop",
      "name",
      "properties",
      "existing",
      "else",
      "tradelog",
      "schema",
      "classes",
      "not"
    ],
    "calls": [
      "add_property",
      "create_class",
      "get"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/ensure_tradelog.py",
    "startLine": 28,
    "endLine": 54,
    "signature": "FunctionDef:ensure_tradelog",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: 函数 ensure_tradelog\n# Params: 无\ndef ensure_tradelog():\n    with weaviate_conn() as client:\n        if \"TradeLog\" in client.collections.list_all():\n            print(\"ℹ️  TradeLog collection already exists, skipped.\")\n            return\n\n        print(f\"[{datetime.utcnow().isoformat()}] Creating TradeLog schema…\")\n\n        client.collections.create(\n            name=\"TradeLog\",\n            description=\"策略交易与因果日志\",\n            properties=[\n                Property(name=\"timestamp\",    data_type=DataType.NUMBER),  # Unix ms\n                Property(name=\"symbol\",       data_type=DataType.TEXT),\n                Property(name=\"signal\",       data_type=DataType.TEXT),\n                Property(name=\"price\",        data_type=DataType.NUMBER),\n                Property(name=\"size\",         data_type=DataType.NUMBER),\n                Property(name=\"stop\",         data_type=DataType.NUMBER),\n                Property(name=\"leverage\",     data_type=DataType.NUMBER),\n                Property(name=\"order_id\",     data_type=DataType.TEXT),\n                Property(name=\"order_status\", data_type=DataType.TEXT),\n                Property(name=\"prompt\",       data_type=DataType.TEXT),\n                Property(name=\"extra\",        data_type=DataType.TEXT),\n            ],\n        )\n\n        print(\"✅ TradeLog collection created.\")",
    "tags": [
      "",
      "=",
      "(",
      "property",
      "_",
      "data",
      "datatype",
      "name",
      ".",
      ")",
      "type",
      "text",
      ",",
      "tradelog",
      "\""
    ],
    "calls": [
      "Property",
      "create",
      "ensure_tradelog",
      "isoformat",
      "list_all",
      "print",
      "utcnow",
      "weaviate_conn"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/ensure_tradelog.py",
    "startLine": 29,
    "endLine": 54,
    "signature": "With:With",
    "parentSignature": [
      "FunctionDef:ensure_tradelog"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: With:With\n# Params: 无\n    with weaviate_conn() as client:\n        if \"TradeLog\" in client.collections.list_all():\n            print(\"ℹ️  TradeLog collection already exists, skipped.\")\n            return\n\n        print(f\"[{datetime.utcnow().isoformat()}] Creating TradeLog schema…\")\n\n        client.collections.create(\n            name=\"TradeLog\",\n            description=\"策略交易与因果日志\",\n            properties=[\n                Property(name=\"timestamp\",    data_type=DataType.NUMBER),  # Unix ms\n                Property(name=\"symbol\",       data_type=DataType.TEXT),\n                Property(name=\"signal\",       data_type=DataType.TEXT),\n                Property(name=\"price\",        data_type=DataType.NUMBER),\n                Property(name=\"size\",         data_type=DataType.NUMBER),\n                Property(name=\"stop\",         data_type=DataType.NUMBER),\n                Property(name=\"leverage\",     data_type=DataType.NUMBER),\n                Property(name=\"order_id\",     data_type=DataType.TEXT),\n                Property(name=\"order_status\", data_type=DataType.TEXT),\n                Property(name=\"prompt\",       data_type=DataType.TEXT),\n                Property(name=\"extra\",        data_type=DataType.TEXT),\n            ],\n        )\n\n        print(\"✅ TradeLog collection created.\")",
    "tags": [
      "",
      "=",
      "(",
      "property",
      "_",
      "data",
      "datatype",
      "name",
      ".",
      ")",
      "type",
      "text",
      ",",
      "tradelog",
      "\""
    ],
    "calls": [
      "Property",
      "create",
      "isoformat",
      "list_all",
      "print",
      "utcnow",
      "weaviate_conn"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_client.py",
    "startLine": 9,
    "endLine": 31,
    "signature": "FunctionDef:get_client",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: 函数 get_client\n# Params: 无\ndef get_client():\n    global _client\n    if _client is None:\n        url = os.getenv(\"WEAVIATE_URL\", \"http://infra-weaviate-1:8080\")\n        params = ConnectionParams.from_url(url, grpc_port=50051)\n\n        max_attempts = 10\n        for i in range(max_attempts):\n            try:\n                client = WeaviateClient(params, skip_init_checks=True)\n                client.connect()\n                # 可选校验 readiness（需要 weaviate-client ≥4.6）\n                if not client.is_ready():  # 或者 schema.get()，看你 prefer 哪个\n                    raise RuntimeError(\"Weaviate not ready\")\n                _client = client\n                atexit.register(_client.close)\n                break\n            except Exception as e:\n                print(f\"[Retry {i+1}/{max_attempts}] Weaviate connect failed: {e}\")\n                time.sleep(3)\n        else:\n            raise RuntimeError(\"Weaviate is not reachable after retries.\")\n    return _client",
    "tags": [
      "",
      "(",
      "=",
      "url",
      "_",
      "client",
      "weaviate",
      "/",
      ".",
      "error_handling",
      ")",
      "is",
      ":",
      ",",
      "\""
    ],
    "calls": [
      "RuntimeError",
      "WeaviateClient",
      "connect",
      "from_url",
      "get",
      "get_client",
      "getenv",
      "is_ready",
      "print",
      "range",
      "register",
      "sleep"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_client.py",
    "startLine": 11,
    "endLine": 30,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:get_client"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: If:If\n# Params: 无\n    if _client is None:\n        url = os.getenv(\"WEAVIATE_URL\", \"http://infra-weaviate-1:8080\")\n        params = ConnectionParams.from_url(url, grpc_port=50051)\n\n        max_attempts = 10\n        for i in range(max_attempts):\n            try:\n                client = WeaviateClient(params, skip_init_checks=True)\n                client.connect()\n                # 可选校验 readiness（需要 weaviate-client ≥4.6）\n                if not client.is_ready():  # 或者 schema.get()，看你 prefer 哪个\n                    raise RuntimeError(\"Weaviate not ready\")\n                _client = client\n                atexit.register(_client.close)\n                break\n            except Exception as e:\n                print(f\"[Retry {i+1}/{max_attempts}] Weaviate connect failed: {e}\")\n                time.sleep(3)\n        else:\n            raise RuntimeError(\"Weaviate is not reachable after retries.\")",
    "tags": [
      "",
      "(",
      "=",
      "url",
      "_",
      "client",
      "weaviate",
      "/",
      ".",
      "error_handling",
      ")",
      "is",
      ":",
      ",",
      "\""
    ],
    "calls": [
      "RuntimeError",
      "WeaviateClient",
      "connect",
      "from_url",
      "get",
      "getenv",
      "is_ready",
      "print",
      "range",
      "register",
      "sleep"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_client.py",
    "startLine": 16,
    "endLine": 30,
    "signature": "For:For",
    "parentSignature": [
      "FunctionDef:get_client"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: For:For\n# Params: 无\n        for i in range(max_attempts):\n            try:\n                client = WeaviateClient(params, skip_init_checks=True)\n                client.connect()\n                # 可选校验 readiness（需要 weaviate-client ≥4.6）\n                if not client.is_ready():  # 或者 schema.get()，看你 prefer 哪个\n                    raise RuntimeError(\"Weaviate not ready\")\n                _client = client\n                atexit.register(_client.close)\n                break\n            except Exception as e:\n                print(f\"[Retry {i+1}/{max_attempts}] Weaviate connect failed: {e}\")\n                time.sleep(3)\n        else:\n            raise RuntimeError(\"Weaviate is not reachable after retries.\")",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "client",
      "weaviate",
      "not",
      ".",
      "error_handling",
      ")",
      ":",
      "i",
      "{",
      "}",
      "\""
    ],
    "calls": [
      "RuntimeError",
      "WeaviateClient",
      "connect",
      "get",
      "is_ready",
      "print",
      "range",
      "register",
      "sleep"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_client.py",
    "startLine": 17,
    "endLine": 28,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:get_client"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: Try:Try\n# Params: 无\n            try:\n                client = WeaviateClient(params, skip_init_checks=True)\n                client.connect()\n                # 可选校验 readiness（需要 weaviate-client ≥4.6）\n                if not client.is_ready():  # 或者 schema.get()，看你 prefer 哪个\n                    raise RuntimeError(\"Weaviate not ready\")\n                _client = client\n                atexit.register(_client.close)\n                break\n            except Exception as e:\n                print(f\"[Retry {i+1}/{max_attempts}] Weaviate connect failed: {e}\")\n                time.sleep(3)",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "client",
      "weaviate",
      ".",
      "error_handling",
      ")",
      "#",
      ":",
      "{",
      "connect",
      "}",
      "\""
    ],
    "calls": [
      "RuntimeError",
      "WeaviateClient",
      "connect",
      "get",
      "is_ready",
      "print",
      "register",
      "sleep"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_schema.py",
    "startLine": 6,
    "endLine": 23,
    "signature": "Assign:Assign",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: Assign:Assign\n# Params: 无\n_SCHEMA = {\n    \"class\": \"TradeLog\",\n    \"description\": \"策略交易与因果日志\",\n    \"properties\": [\n        {\"name\": \"timestamp\",    \"dataType\": [\"number\"]},\n        {\"name\": \"symbol\",       \"dataType\": [\"text\"]},\n        {\"name\": \"signal\",       \"dataType\": [\"text\"]},\n        {\"name\": \"price\",        \"dataType\": [\"number\"]},\n        {\"name\": \"size\",         \"dataType\": [\"number\"]},\n        {\"name\": \"leverage\",     \"dataType\": [\"number\"]},\n        {\"name\": \"order_id\",     \"dataType\": [\"text\"]},\n        {\"name\": \"status\",       \"dataType\": [\"text\"]},\n        {\"name\": \"prompt\",       \"dataType\": [\"text\"]},\n        {\"name\": \"extra\",        \"dataType\": [\"text\"]},\n        {\"name\": \"pnl_realized\", \"dataType\": [\"number\"]},\n        {\"name\": \"equity\",       \"dataType\": [\"number\"]},\n    ],\n}",
    "tags": [
      "",
      "number",
      "=",
      "_",
      "datatype",
      "]",
      "name",
      "[",
      ":",
      "{",
      "text",
      ",",
      "schema",
      "}",
      "\""
    ],
    "calls": [],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_schema.py",
    "startLine": 35,
    "endLine": 56,
    "signature": "FunctionDef:ensure_schema",
    "parentSignature": [],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: 函数 ensure_schema\n# Params: 无\ndef ensure_schema():\n    client = None\n    try:\n        client = get_client()\n        schema = client.schema_api.get()\n        classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n\n        if \"TradeLog\" not in classes:\n            client.schema_api.create_class(_SCHEMA)\n            logging.info(\"Weaviate: created TradeLog class\")\n        else:\n            trade_cls = next(c for c in schema[\"classes\"] if c[\"class\"] == \"TradeLog\")\n            existing = {p[\"name\"] for p in trade_cls.get(\"properties\", [])}\n            for prop in _SCHEMA[\"properties\"]:\n                if prop[\"name\"] not in existing:\n                    client.schema_api.add_property(\"TradeLog\", prop)\n                    logging.info(f\"Weaviate: added property '{prop['name']}' to TradeLog\")\n    except Exception as e:\n        logging.warning(f\"Weaviate schema ensure failed: {e}\")\n    finally:\n        if client:\n            client.close()",
    "tags": [
      "info",
      "weaviate",
      "client",
      "get",
      "prop",
      "name",
      "error_handling",
      "api",
      "ensure",
      "trade",
      "tradelog",
      "schema",
      "logging",
      "classes",
      "not"
    ],
    "calls": [
      "add_property",
      "close",
      "create_class",
      "ensure_schema",
      "get",
      "get_client",
      "info",
      "next",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/storage/weaviate_schema.py",
    "startLine": 37,
    "endLine": 56,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:ensure_schema"
    ],
    "moduleName": "storage",
    "importPath": "/root/kk/src/storage",
    "content": "# Summary: Try:Try\n# Params: 无\n    try:\n        client = get_client()\n        schema = client.schema_api.get()\n        classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n\n        if \"TradeLog\" not in classes:\n            client.schema_api.create_class(_SCHEMA)\n            logging.info(\"Weaviate: created TradeLog class\")\n        else:\n            trade_cls = next(c for c in schema[\"classes\"] if c[\"class\"] == \"TradeLog\")\n            existing = {p[\"name\"] for p in trade_cls.get(\"properties\", [])}\n            for prop in _SCHEMA[\"properties\"]:\n                if prop[\"name\"] not in existing:\n                    client.schema_api.add_property(\"TradeLog\", prop)\n                    logging.info(f\"Weaviate: added property '{prop['name']}' to TradeLog\")\n    except Exception as e:\n        logging.warning(f\"Weaviate schema ensure failed: {e}\")\n    finally:\n        if client:\n            client.close()",
    "tags": [
      "info",
      "weaviate",
      "client",
      "get",
      "prop",
      "name",
      "error_handling",
      "cls",
      "api",
      "trade",
      "tradelog",
      "schema",
      "logging",
      "classes",
      "not"
    ],
    "calls": [
      "add_property",
      "close",
      "create_class",
      "get",
      "get_client",
      "info",
      "next",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market.py",
    "startLine": 33,
    "endLine": 86,
    "signature": "FunctionDef:get_instrument_spec",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: 函数 get_instrument_spec\n# Params: symbol:str=None\ndef get_instrument_spec(\n    symbol: str,\n    *,\n    bar: str = \"1m\",\n    limit: int = 30,\n    cache_seconds: int = 60,\n) -> dict:\n    \"\"\"\n    返回 dict 字段：\n      ct_val, min_sz, lot_sz, period_sec,\n      recent_prices, recent_high, recent_low\n    \"\"\"\n    key = (symbol, bar, limit)\n    now = time.time()\n\n    # 1. cache\n    ts_cached, spec_cached = _CACHE.get(key, (0, None))\n    hit = spec_cached and now - ts_cached < cache_seconds\n    print(f\"[spec-cache] {symbol} hit={bool(hit)} ts={int(ts_cached)} now={int(now)}\")\n    if hit:\n        return spec_cached\n\n    # 2. pull fresh\n    try:\n        raw = _fetch_instrument_raw(symbol)\n        df = _fetch_candles(symbol, bar, limit)\n        ct_val = float(raw[\"ctVal\"])\n        # minSz / lotSz 可能是 \"0.01\" → 转成 float\n        min_sz = math.ceil(float(raw[\"minSz\"]))\n        lot_sz = float(raw[\"lotSz\"])  # 保留小数，不转 int\n        spec = {\n            \"ct_val\": ct_val,\n            \"min_sz\": min_sz,\n            \"lot_sz\": lot_sz,\n            \"period_sec\": 60,\n            \"recent_prices\": df[\"c\"],\n            \"recent_high\": df[\"h\"],\n            \"recent_low\": df[\"l\"],\n        }\n    except Exception as e:\n        print(\"⚠️  get_instrument_spec 拉取失败，用默认值:\", e)\n        spec = {\n            \"ct_val\": 0.01,\n            \"min_sz\": 1,\n            \"lot_sz\": 1,\n            \"period_sec\": 60,\n            \"recent_prices\": pd.Series([0]),\n            \"recent_high\": pd.Series([0]),\n            \"recent_low\": pd.Series([0]),\n        }\n\n    # 3. store cache\n    _CACHE[key] = (now, spec)\n    return spec",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "]",
      "[",
      "error_handling",
      ")",
      ".",
      "sz",
      ":",
      "spec",
      ",",
      "recent",
      "\""
    ],
    "calls": [
      "Series",
      "_fetch_candles",
      "_fetch_instrument_raw",
      "bool",
      "ceil",
      "float",
      "get",
      "get_instrument_spec",
      "int",
      "print",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "返回 dict 字段：\n      ct_val, min_sz, lot_sz, period_sec,\n      recent_prices, recent_high, recent_low"
  },
  {
    "filePath": "/root/kk/src/trade/market.py",
    "startLine": 56,
    "endLine": 82,
    "signature": "Try:Try",
    "parentSignature": [
      "FunctionDef:get_instrument_spec"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Try:Try\n# Params: 无\n    try:\n        raw = _fetch_instrument_raw(symbol)\n        df = _fetch_candles(symbol, bar, limit)\n        ct_val = float(raw[\"ctVal\"])\n        # minSz / lotSz 可能是 \"0.01\" → 转成 float\n        min_sz = math.ceil(float(raw[\"minSz\"]))\n        lot_sz = float(raw[\"lotSz\"])  # 保留小数，不转 int\n        spec = {\n            \"ct_val\": ct_val,\n            \"min_sz\": min_sz,\n            \"lot_sz\": lot_sz,\n            \"period_sec\": 60,\n            \"recent_prices\": df[\"c\"],\n            \"recent_high\": df[\"h\"],\n            \"recent_low\": df[\"l\"],\n        }\n    except Exception as e:\n        print(\"⚠️  get_instrument_spec 拉取失败，用默认值:\", e)\n        spec = {\n            \"ct_val\": 0.01,\n            \"min_sz\": 1,\n            \"lot_sz\": 1,\n            \"period_sec\": 60,\n            \"recent_prices\": pd.Series([0]),\n            \"recent_high\": pd.Series([0]),\n            \"recent_low\": pd.Series([0]),\n        }",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "]",
      "[",
      "error_handling",
      ")",
      "df",
      "sz",
      ":",
      ",",
      "raw",
      "recent",
      "\""
    ],
    "calls": [
      "Series",
      "_fetch_candles",
      "_fetch_instrument_raw",
      "ceil",
      "float",
      "print"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 15,
    "endLine": 32,
    "signature": "AsyncFunctionDef:binance_ws_price",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Async函数 binance_ws_price\n# Params: symbol:None='ETHUSDT', callback:None=None, backoff:None=5\nasync def binance_ws_price(symbol=\"ETHUSDT\", callback=None, backoff=5):\n    from binance import AsyncClient, BinanceSocketManager\n    while True:\n        client = await AsyncClient.create()\n        bm = BinanceSocketManager(client)\n        try:\n            async with bm.aggtrade_socket(symbol.upper()) as stream:\n                logging.info(f\"[Binance] Connected {symbol.upper()}\")\n                while True:\n                    msg = await stream.recv()\n                    price = float(msg.get(\"p\", 0))\n                    if callback:\n                        asyncio.create_task(_safe_callback(callback, price, \"BINANCE\"))\n        except Exception:\n            logging.exception(\"[Binance] ws error\")\n            await asyncio.sleep(backoff)\n        finally:\n            await client.close_connection()",
    "tags": [
      "binance",
      "true",
      "await",
      "client",
      "asyncclient",
      "upper",
      "stream",
      "error_handling",
      "async",
      "price",
      "symbol",
      "callback",
      "create",
      "binancesocketmanager",
      "retry"
    ],
    "calls": [
      "BinanceSocketManager",
      "_safe_callback",
      "aggtrade_socket",
      "binance_ws_price",
      "close_connection",
      "create",
      "create_task",
      "exception",
      "float",
      "get",
      "info",
      "recv",
      "sleep",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 34,
    "endLine": 61,
    "signature": "AsyncFunctionDef:okx_ws_ticker",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Async函数 okx_ws_ticker\n# Params: symbol:None='ETH-USDT-SWAP', callback:None=None, backoff:None=5\nasync def okx_ws_ticker(symbol=\"ETH-USDT-SWAP\", callback=None, backoff=5):\n    import websockets, time\n    OKX_WS_URL = \"wss://ws.okx.com:8443/ws/v5/public\"\n    while True:\n        try:\n            async with websockets.connect(OKX_WS_URL) as ws:\n                await ws.send(json.dumps({\n                    \"op\": \"subscribe\",\n                    \"args\": [{\"channel\": \"tickers\", \"instType\": \"SWAP\", \"instId\": symbol}]\n                }))\n                logging.info(f\"[OKX] Connected {symbol}\")\n                async for msg in ws:\n                    data = json.loads(msg)\n                    if data.get(\"op\") == \"ping\":\n                        await ws.send(json.dumps({\"op\": \"pong\"}))\n                        continue\n                    if \"data\" not in data:\n                        continue\n                    try:\n                        price = float(data[\"data\"][0][\"last\"])\n                        if callback:\n                            asyncio.create_task(_safe_callback(callback, price, \"OKX\"))\n                    except (KeyError, IndexError, ValueError) as e:\n                        logging.warning(f\"[OKX] Invalid ticker data: {data}\")\n                        continue\n        except Exception:\n            logging.exception(\"[OKX] ws error\")\n            await asyncio.sleep(backoff)",
    "tags": [
      "ticker",
      "url",
      "data",
      "swap",
      "await",
      "websockets",
      "continue",
      "error_handling",
      "okx",
      "async",
      "json",
      "symbol",
      "callback",
      "logging",
      "retry"
    ],
    "calls": [
      "_safe_callback",
      "connect",
      "create_task",
      "dumps",
      "except",
      "exception",
      "float",
      "get",
      "info",
      "loads",
      "okx_ws_ticker",
      "send",
      "sleep",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 17,
    "endLine": 32,
    "signature": "While:While",
    "parentSignature": [
      "AsyncFunctionDef:binance_ws_price"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: While:While\n# Params: 无\n    while True:\n        client = await AsyncClient.create()\n        bm = BinanceSocketManager(client)\n        try:\n            async with bm.aggtrade_socket(symbol.upper()) as stream:\n                logging.info(f\"[Binance] Connected {symbol.upper()}\")\n                while True:\n                    msg = await stream.recv()\n                    price = float(msg.get(\"p\", 0))\n                    if callback:\n                        asyncio.create_task(_safe_callback(callback, price, \"BINANCE\"))\n        except Exception:\n            logging.exception(\"[Binance] ws error\")\n            await asyncio.sleep(backoff)\n        finally:\n            await client.close_connection()",
    "tags": [
      "binance",
      "true",
      "client",
      "await",
      "upper",
      "stream",
      "error_handling",
      "price",
      "retry",
      "asyncio",
      "symbol",
      "callback",
      "create",
      "logging",
      "msg"
    ],
    "calls": [
      "BinanceSocketManager",
      "_safe_callback",
      "aggtrade_socket",
      "close_connection",
      "create",
      "create_task",
      "exception",
      "float",
      "get",
      "info",
      "recv",
      "sleep",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 37,
    "endLine": 61,
    "signature": "While:While",
    "parentSignature": [
      "AsyncFunctionDef:okx_ws_ticker"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: While:While\n# Params: 无\n    while True:\n        try:\n            async with websockets.connect(OKX_WS_URL) as ws:\n                await ws.send(json.dumps({\n                    \"op\": \"subscribe\",\n                    \"args\": [{\"channel\": \"tickers\", \"instType\": \"SWAP\", \"instId\": symbol}]\n                }))\n                logging.info(f\"[OKX] Connected {symbol}\")\n                async for msg in ws:\n                    data = json.loads(msg)\n                    if data.get(\"op\") == \"ping\":\n                        await ws.send(json.dumps({\"op\": \"pong\"}))\n                        continue\n                    if \"data\" not in data:\n                        continue\n                    try:\n                        price = float(data[\"data\"][0][\"last\"])\n                        if callback:\n                            asyncio.create_task(_safe_callback(callback, price, \"OKX\"))\n                    except (KeyError, IndexError, ValueError) as e:\n                        logging.warning(f\"[OKX] Invalid ticker data: {data}\")\n                        continue\n        except Exception:\n            logging.exception(\"[OKX] ws error\")\n            await asyncio.sleep(backoff)",
    "tags": [
      "data",
      "await",
      "send",
      "continue",
      "error_handling",
      "okx",
      "async",
      "try",
      "price",
      "json",
      "symbol",
      "callback",
      "dumps",
      "logging",
      "msg"
    ],
    "calls": [
      "_safe_callback",
      "connect",
      "create_task",
      "dumps",
      "except",
      "exception",
      "float",
      "get",
      "info",
      "loads",
      "send",
      "sleep",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 20,
    "endLine": 32,
    "signature": "Try:Try",
    "parentSignature": [
      "AsyncFunctionDef:binance_ws_price"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Try:Try\n# Params: 无\n        try:\n            async with bm.aggtrade_socket(symbol.upper()) as stream:\n                logging.info(f\"[Binance] Connected {symbol.upper()}\")\n                while True:\n                    msg = await stream.recv()\n                    price = float(msg.get(\"p\", 0))\n                    if callback:\n                        asyncio.create_task(_safe_callback(callback, price, \"BINANCE\"))\n        except Exception:\n            logging.exception(\"[Binance] ws error\")\n            await asyncio.sleep(backoff)\n        finally:\n            await client.close_connection()",
    "tags": [
      "binance",
      "await",
      "upper",
      "stream",
      "error_handling",
      "async",
      "price",
      "try",
      "with",
      "retry",
      "asyncio",
      "symbol",
      "callback",
      "logging",
      "msg"
    ],
    "calls": [
      "_safe_callback",
      "aggtrade_socket",
      "close_connection",
      "create_task",
      "exception",
      "float",
      "get",
      "info",
      "recv",
      "sleep",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws.py",
    "startLine": 38,
    "endLine": 61,
    "signature": "Try:Try",
    "parentSignature": [
      "AsyncFunctionDef:okx_ws_ticker"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Try:Try\n# Params: 无\n        try:\n            async with websockets.connect(OKX_WS_URL) as ws:\n                await ws.send(json.dumps({\n                    \"op\": \"subscribe\",\n                    \"args\": [{\"channel\": \"tickers\", \"instType\": \"SWAP\", \"instId\": symbol}]\n                }))\n                logging.info(f\"[OKX] Connected {symbol}\")\n                async for msg in ws:\n                    data = json.loads(msg)\n                    if data.get(\"op\") == \"ping\":\n                        await ws.send(json.dumps({\"op\": \"pong\"}))\n                        continue\n                    if \"data\" not in data:\n                        continue\n                    try:\n                        price = float(data[\"data\"][0][\"last\"])\n                        if callback:\n                            asyncio.create_task(_safe_callback(callback, price, \"OKX\"))\n                    except (KeyError, IndexError, ValueError) as e:\n                        logging.warning(f\"[OKX] Invalid ticker data: {data}\")\n                        continue\n        except Exception:\n            logging.exception(\"[OKX] ws error\")\n            await asyncio.sleep(backoff)",
    "tags": [
      "data",
      "await",
      "send",
      "continue",
      "error_handling",
      "okx",
      "async",
      "try",
      "price",
      "json",
      "symbol",
      "callback",
      "dumps",
      "logging",
      "msg"
    ],
    "calls": [
      "_safe_callback",
      "connect",
      "create_task",
      "dumps",
      "except",
      "exception",
      "float",
      "get",
      "info",
      "loads",
      "send",
      "sleep",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws_okx.py",
    "startLine": 10,
    "endLine": 30,
    "signature": "AsyncFunctionDef:subscribe_okx",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: Async函数 subscribe_okx\n# Params: 无\nasync def subscribe_okx():\n    async with websockets.connect(OKX_WS_URL) as ws:\n        await ws.send(json.dumps({\n            \"op\": \"subscribe\",\n            \"args\": [{\"channel\": \"tickers\", \"instType\": \"SPOT\", \"instId\": \"ETH-USDT\"}]\n        }))\n        print(f\"[{time.strftime('%Y-%m-%d %H:%M:%S')}] 已发送订阅请求，开始接收…\")\n        while True:\n            msg = await ws.recv()\n            data = json.loads(msg)\n            # 如果是订阅确认或心跳，就打印一下或跳过\n            if data.get(\"event\") in (\"subscribe\", \"error\", \"heartbeat\"):\n                print(\"系统消息：\", data)\n                continue\n            # 只有当存在实际行情数据时才处理\n            if data.get(\"arg\", {}).get(\"channel\") == \"tickers\" and \"data\" in data:\n                d = data[\"data\"][0]\n                print(f\"[OKX {d['ts']}] {d['instId']} 最后价 = {d['last']}\")\n            else:\n                # 其它消息暂不处理\n                continue",
    "tags": [
      "",
      "(",
      "=",
      "'",
      "_",
      "data",
      "]",
      ".",
      "[",
      ")",
      "error_handling",
      ":",
      "{",
      ",",
      "}",
      "\""
    ],
    "calls": [
      "connect",
      "dumps",
      "get",
      "in",
      "loads",
      "print",
      "recv",
      "send",
      "strftime",
      "subscribe_okx"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/market_ws_okx.py",
    "startLine": 17,
    "endLine": 30,
    "signature": "While:While",
    "parentSignature": [
      "AsyncFunctionDef:subscribe_okx"
    ],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: While:While\n# Params: 无\n        while True:\n            msg = await ws.recv()\n            data = json.loads(msg)\n            # 如果是订阅确认或心跳，就打印一下或跳过\n            if data.get(\"event\") in (\"subscribe\", \"error\", \"heartbeat\"):\n                print(\"系统消息：\", data)\n                continue\n            # 只有当存在实际行情数据时才处理\n            if data.get(\"arg\", {}).get(\"channel\") == \"tickers\" and \"data\" in data:\n                d = data[\"data\"][0]\n                print(f\"[OKX {d['ts']}] {d['instId']} 最后价 = {d['last']}\")\n            else:\n                # 其它消息暂不处理\n                continue",
    "tags": [
      "",
      "(",
      "=",
      "data",
      "'",
      "]",
      "[",
      ".",
      ")",
      "error_handling",
      ":",
      "d",
      "{",
      ",",
      "}",
      "\""
    ],
    "calls": [
      "get",
      "in",
      "loads",
      "print",
      "recv"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/order.py",
    "startLine": 35,
    "endLine": 68,
    "signature": "FunctionDef:place_order",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: 函数 place_order\n# Params: symbol:str=None, side:Literal['BUY', 'SELL']=None, qty:float=None\ndef place_order(\n    symbol: str,\n    side: Literal[\"BUY\", \"SELL\"],\n    qty: float,\n    *,\n    td_mode: Literal[\"isolated\", \"cross\"] = \"isolated\",\n    leverage: Optional[float] = None,\n    min_sz: float,\n    lot_sz: float,\n    reduce_only: bool = False,\n) -> Dict[str, Any]:\n    if qty < min_sz or abs((qty / lot_sz) - round(qty / lot_sz)) > 1e-8:\n        return {\"id\": \"\", \"status\": \"SIZE_TOO_SMALL\", \"api_response\": {}}\n\n    params: Dict[str, Any] = dict(\n        instId   = symbol,\n        tdMode   = td_mode,\n        ordType  = \"market\",\n        side     = side.lower(),\n        sz       = str(qty),\n        ccy      = \"USDT\",\n        posSide  = \"long\" if side == \"BUY\" else \"short\",\n    )\n    if reduce_only:\n        params[\"reduceOnly\"] = \"true\"\n\n    try:\n        res = _trade().place_order(**params)\n        data0 = (res.get(\"data\") or [{}])[0]\n        fee = abs(float(data0.get(\"fee\", 0)))\n        okx_fees_usdt_total.inc(fee)\n        return {\"id\": data0.get(\"ordId\", \"\"), \"status\": res.get(\"code\", \"X\"), \"api_response\": res}\n    except Exception as e:\n        return {\"id\": \"\", \"status\": \"EXCEPTION\", \"error\": str(e)}",
    "tags": [
      "res",
      "lot",
      "data",
      "dict",
      "str",
      "get",
      "float",
      "error_handling",
      "status",
      "api",
      "side",
      "params",
      "qty",
      "place",
      "fee"
    ],
    "calls": [
      "_trade",
      "abs",
      "dict",
      "float",
      "get",
      "inc",
      "lower",
      "place_order",
      "round",
      "str"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/trade/order.py",
    "startLine": 73,
    "endLine": 103,
    "signature": "FunctionDef:place_algo_order_trailing_sl",
    "parentSignature": [],
    "moduleName": "trade",
    "importPath": "/root/kk/src/trade",
    "content": "# Summary: 函数 place_algo_order_trailing_sl\n# Params: symbol:str=None, side:Literal['BUY', 'SELL']=None, trigger_px:str=None, callback_rate:str=None\ndef place_algo_order_trailing_sl(\n    symbol: str,\n    side: Literal[\"BUY\", \"SELL\"],          # 仍按开仓方向传进来\n    trigger_px: str,\n    callback_rate: str,\n) -> Dict[str, Any]:\n    \"\"\"\n    下原生 trailing-stop：\n      trigger_px    = 开仓价\n      callback_rate = \"0.5\" 表示 0.5 %\n    \"\"\"\n    # 1. 计算平仓方向\n    close_side = \"sell\" if side == \"BUY\" else \"buy\"\n    pos_side   = \"long\" if side == \"BUY\" else \"short\"\n\n    params: Dict[str, Any] = {\n        \"instId\"       : symbol,\n        \"tdMode\"       : \"isolated\",\n        \"side\"         : close_side,          # **反向平仓**\n        \"posSide\"      : pos_side,\n        \"ordType\"      : \"trailing_stop\",     # ← 对应 OKX v5 文档\n        \"sz\"           : \"0\",                 # OKX 要求填写，可填 0\n        \"triggerPx\"    : trigger_px,          # 字段名改为 triggerPx\n        \"callbackRatio\": callback_rate,       # \"0.5\" → 0.5 %\n    }\n    try:\n        res = _trade().place_algo_order(**params)\n        return res\n    except Exception as e:\n        print(\"❌ place_algo_order_trailing_sl 异常:\", e)\n        return {\"code\": \"-1\", \"msg\": str(e)}",
    "tags": [
      "",
      "=",
      "*",
      "(",
      "_",
      "str",
      "error_handling",
      "#",
      ")",
      "trailing",
      ":",
      "side",
      ",",
      "buy",
      "\""
    ],
    "calls": [
      "_trade",
      "place_algo_order",
      "place_algo_order_trailing_sl",
      "print",
      "str"
    ],
    "called_by": [],
    "imports": [],
    "docstring": "下原生 trailing-stop：\n      trigger_px    = 开仓价\n      callback_rate = \"0.5\" 表示 0.5 %"
  },
  {
    "filePath": "/root/kk/src/utils/config_loader.py",
    "startLine": 14,
    "endLine": 47,
    "signature": "FunctionDef:load",
    "parentSignature": [],
    "moduleName": "utils",
    "importPath": "/root/kk/src/utils",
    "content": "# Summary: 函数 load\n# Params: path:str | pathlib.Path='configs/config.yaml'\ndef load(path: str | pathlib.Path = \"configs/config.yaml\") -> dict:\n    global _CFG_CACHE\n    if _CFG_CACHE is not None:\n        return _CFG_CACHE\n\n    with open(path, \"r\") as f:\n        cfg = yaml.safe_load(f)\n\n    override = pathlib.Path(\"configs/config.override.yaml\")\n    if override.exists():\n        with open(override, \"r\") as f:\n            cfg = _deep_merge(cfg, yaml.safe_load(f) or {})\n\n    # 环境变量覆盖\n    def _env_override(node: dict, prefix: str = \"\"):\n        for k, v in node.items():\n            env_key = (prefix + k).upper()\n            if isinstance(v, dict):\n                _env_override(v, env_key + \"_\")\n            else:\n                ev = os.getenv(env_key)\n                if ev is not None:\n                    if isinstance(v, bool):\n                        node[k] = ev.lower() in (\"1\", \"true\", \"yes\")\n                    elif isinstance(v, numbers.Integral):\n                        node[k] = int(ev)\n                    elif isinstance(v, numbers.Real):\n                        node[k] = float(ev)\n                    else:\n                        node[k] = ev\n    _env_override(cfg)\n\n    _CFG_CACHE = cfg\n    return cfg",
    "tags": [
      "",
      "(",
      "=",
      "override",
      "env",
      "config",
      "_",
      "node",
      ".",
      ")",
      "v",
      ":",
      "cfg",
      ",",
      "k",
      "\""
    ],
    "calls": [
      "Path",
      "_deep_merge",
      "_env_override",
      "exists",
      "float",
      "getenv",
      "in",
      "int",
      "isinstance",
      "items",
      "load",
      "lower",
      "open",
      "safe_load",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/utils/config_loader.py",
    "startLine": 28,
    "endLine": 43,
    "signature": "FunctionDef:_env_override",
    "parentSignature": [
      "FunctionDef:load"
    ],
    "moduleName": "utils",
    "importPath": "/root/kk/src/utils",
    "content": "# Summary: 函数 _env_override\n# Params: node:dict=None, prefix:str=''\n    def _env_override(node: dict, prefix: str = \"\"):\n        for k, v in node.items():\n            env_key = (prefix + k).upper()\n            if isinstance(v, dict):\n                _env_override(v, env_key + \"_\")\n            else:\n                ev = os.getenv(env_key)\n                if ev is not None:\n                    if isinstance(v, bool):\n                        node[k] = ev.lower() in (\"1\", \"true\", \"yes\")\n                    elif isinstance(v, numbers.Integral):\n                        node[k] = int(ev)\n                    elif isinstance(v, numbers.Real):\n                        node[k] = float(ev)\n                    else:\n                        node[k] = ev",
    "tags": [
      "env",
      "key",
      "elif",
      "dict",
      "upper",
      "numbers",
      "str",
      "getenv",
      "not",
      "isinstance",
      "prefix",
      "node",
      "else",
      "items",
      "override"
    ],
    "calls": [
      "_env_override",
      "float",
      "getenv",
      "in",
      "int",
      "isinstance",
      "items",
      "lower",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/utils/config_loader.py",
    "startLine": 29,
    "endLine": 43,
    "signature": "For:For",
    "parentSignature": [
      "FunctionDef:load",
      "FunctionDef:_env_override"
    ],
    "moduleName": "utils",
    "importPath": "/root/kk/src/utils",
    "content": "# Summary: For:For\n# Params: 无\n        for k, v in node.items():\n            env_key = (prefix + k).upper()\n            if isinstance(v, dict):\n                _env_override(v, env_key + \"_\")\n            else:\n                ev = os.getenv(env_key)\n                if ev is not None:\n                    if isinstance(v, bool):\n                        node[k] = ev.lower() in (\"1\", \"true\", \"yes\")\n                    elif isinstance(v, numbers.Integral):\n                        node[k] = int(ev)\n                    elif isinstance(v, numbers.Real):\n                        node[k] = float(ev)\n                    else:\n                        node[k] = ev",
    "tags": [
      "env",
      "key",
      "elif",
      "dict",
      "upper",
      "numbers",
      "getenv",
      "not",
      "none",
      "isinstance",
      "prefix",
      "node",
      "else",
      "items",
      "override"
    ],
    "calls": [
      "_env_override",
      "float",
      "getenv",
      "in",
      "int",
      "isinstance",
      "items",
      "lower",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/src/utils/config_loader.py",
    "startLine": 31,
    "endLine": 43,
    "signature": "If:If",
    "parentSignature": [
      "FunctionDef:load",
      "FunctionDef:_env_override"
    ],
    "moduleName": "utils",
    "importPath": "/root/kk/src/utils",
    "content": "# Summary: If:If\n# Params: 无\n            if isinstance(v, dict):\n                _env_override(v, env_key + \"_\")\n            else:\n                ev = os.getenv(env_key)\n                if ev is not None:\n                    if isinstance(v, bool):\n                        node[k] = ev.lower() in (\"1\", \"true\", \"yes\")\n                    elif isinstance(v, numbers.Integral):\n                        node[k] = int(ev)\n                    elif isinstance(v, numbers.Real):\n                        node[k] = float(ev)\n                    else:\n                        node[k] = ev",
    "tags": [
      "env",
      "key",
      "elif",
      "dict",
      "true",
      "numbers",
      "getenv",
      "not",
      "none",
      "isinstance",
      "bool",
      "lower",
      "node",
      "else",
      "override"
    ],
    "calls": [
      "_env_override",
      "float",
      "getenv",
      "in",
      "int",
      "isinstance",
      "lower"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 57,
    "endLine": 74,
    "signature": "FunctionDef:_load_balance",
    "parentSignature": [],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: 函数 _load_balance\n# Params: 无\ndef _load_balance() -> float:\n    global _BAL_CACHE\n    ts, bal = _BAL_CACHE\n    if time.time() - ts < 30:\n        return bal\n    cli = _acct.AccountAPI(\n        api_key        = os.getenv(\"OKX_API_KEY\", \"\"),\n        api_secret_key = os.getenv(\"OKX_API_SECRET\", \"\"),\n        passphrase     = os.getenv(\"OKX_API_PASSPHRASE\", \"\"),\n        flag           = os.getenv(\"OKX_API_FLAG\", \"1\"),\n    )\n    try:\n        bal = float(cli.get_account_balance(ccy=\"USDT\")[\"data\"][0][\"details\"][0][\"cashBal\"])\n    except Exception:\n        bal = 0.0\n    equity_usdt.set(bal)\n    _BAL_CACHE = (time.time(), bal)\n    return bal",
    "tags": [
      "time",
      "key",
      "secret",
      "getenv",
      "usdt",
      "float",
      "error_handling",
      "load",
      "api",
      "okx",
      "loadbalance",
      "cli",
      "flag",
      "cache",
      "passphrase"
    ],
    "calls": [
      "AccountAPI",
      "_load_balance",
      "float",
      "get_account_balance",
      "getenv",
      "set",
      "time"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 79,
    "endLine": 109,
    "signature": "AsyncFunctionDef:llm_decide",
    "parentSignature": [],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: Async函数 llm_decide\n# Params: price:float=None, pos:str | None=None, spec:dict=None\nasync def llm_decide(price: float, pos: str | None, spec: dict):\n    async with _gpt_lock:\n        rh = spec.get(\"recent_high\")   # 可能为 None\n        rl = spec.get(\"recent_low\")\n        atr = float(rh.tail(14).mean() - rl.tail(14).mean()) if (rh is not None and rl is not None) else 0\n\n        payload = {\n            \"price\":    price,\n            \"position\": pos or \"FLAT\",\n            \"balance\":  _load_balance(),\n            \"atr\":      atr\n        }\n        prompt = \"策略输入: \" + json.dumps(payload, ensure_ascii=False) + \\\n                 \"\\n输出 JSON: {\\\"side\\\":\\\"BUY|SELL|HOLD\\\",\\\"qty\\\":整数}\"\n\n        t0 = time.time()\n        try:\n            resp = await asyncio.to_thread(lambda: openai.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.2,\n                response_format={\"type\": \"json_object\"},\n                timeout=6\n            ))\n            gpt_latency_seconds.observe(time.time() - t0)\n            gpt_requests_total.inc()\n            data = json.loads(resp.choices[0].message.content)\n            return data.get(\"side\", \"HOLD\").upper(), prompt, data\n        except Exception as e:\n            logging.warning(\"GPT err %s\", e)\n            return \"HOLD\", prompt, {\"err\": str(e)}",
    "tags": [
      "",
      "(",
      "=",
      "gpt",
      "_",
      "none",
      ".",
      "error_handling",
      ")",
      "\\",
      ":",
      "{",
      ",",
      "}",
      "\""
    ],
    "calls": [
      "_load_balance",
      "create",
      "dumps",
      "float",
      "get",
      "if",
      "inc",
      "llm_decide",
      "loads",
      "mean",
      "observe",
      "str",
      "tail",
      "time",
      "to_thread",
      "upper",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 114,
    "endLine": 132,
    "signature": "ClassDef:RealBroker",
    "parentSignature": [],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: 类 RealBroker\n# Params: 无\nclass RealBroker:\n    def __init__(self):\n        self.symbol = cfg[\"trade\"][\"symbol\"]\n        self.spec   = get_instrument_spec(self.symbol)\n        self.min_sz = self.spec[\"min_sz\"]\n        self.lot_sz = self.spec[\"lot_sz\"]\n\n    async def open_long(self, qty=None, price=None):\n        return await asyncio.to_thread(place_order,\n            self.symbol, \"BUY\", max(qty or 1, self.min_sz),\n            min_sz=self.min_sz, lot_sz=self.lot_sz)\n\n    async def open_short(self, qty=None, price=None):\n        return await asyncio.to_thread(place_order,\n            self.symbol, \"SELL\", max(qty or 1, self.min_sz),\n            min_sz=self.min_sz, lot_sz=self.lot_sz)\n\n    async def close_all(self):\n        pass",
    "tags": [
      "lot",
      "asyncio",
      "await",
      "thread",
      "none",
      "async",
      "min",
      "spec",
      "qty",
      "open",
      "price",
      "self",
      "place",
      "symbol",
      "order"
    ],
    "calls": [
      "__init__",
      "close_all",
      "get_instrument_spec",
      "max",
      "open_long",
      "open_short",
      "to_thread"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 151,
    "endLine": 195,
    "signature": "AsyncFunctionDef:main",
    "parentSignature": [],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: Async函数 main\n# Params: 无\nasync def main():\n    q     = asyncio.Queue(maxsize=1000)\n    last  = None\n\n    asyncio.create_task(price_feeder(q))\n    filt = SignalFilter(**cfg[\"signal\"])\n\n    signal.signal(signal.SIGHUP, lambda *_: cfg.update(load_cfg()))\n\n    while True:\n        price = await q.get()\n        last  = last or price\n\n        if trailing_mgr().update(price):\n            trailing_stop_hits_total.inc()\n            await broker.close_all()\n            await PositionGuard().reset()\n\n            try:\n                cli = get_client()\n                col = cli.collections.get(\"TradeLog\")\n                uuid = col.query.fetch_objects(limit=1)[0].uuid\n                col.data.update(uuid, {\"trail_sl_hit\": \"true\"})\n            except Exception:\n                pass\n            last = price\n            continue\n\n        direction = \"BUY\" if price > last else \"SELL\" if price < last else \"HOLD\"\n        if filt.push(direction):\n            pos = await PositionGuard().get()\n\n            cache_key = {\"sym\": broker.symbol, \"side\": direction,\n                         \"zone\": round(price * 500) / 500}\n            significant = event_cls.push(price) and not hit_or_set(cache_key)\n\n            if significant:\n                sig, prompt, extra = await llm_decide(price, pos, broker.spec)\n            else:\n                raw, _ = await ask_local_llm(f\"eth price {price:.2f}, answer BUY SELL HOLD\")\n                sig, prompt, extra = raw.strip().upper()[:4], \"gemma quick\", {\"gemma_raw\": raw}\n\n            await agent_decide_and_execute(sig, price, broker,\n                                           prompt=prompt, extra=extra)\n        last = price",
    "tags": [
      "update_logic",
      "broker",
      "await",
      "prompt",
      "get",
      "error_handling",
      "signal",
      "col",
      "price",
      "extra",
      "cfg",
      "last",
      "raw",
      "uuid",
      "direction"
    ],
    "calls": [
      "PositionGuard",
      "Queue",
      "SignalFilter",
      "agent_decide_and_execute",
      "ask_local_llm",
      "close_all",
      "create_task",
      "fetch_objects",
      "get",
      "get_client",
      "hit_or_set",
      "inc",
      "llm_decide",
      "load_cfg",
      "main",
      "price_feeder",
      "push",
      "reset",
      "round",
      "signal",
      "strip",
      "trailing_mgr",
      "update",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 160,
    "endLine": 195,
    "signature": "While:While",
    "parentSignature": [
      "AsyncFunctionDef:main"
    ],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: While:While\n# Params: 无\n    while True:\n        price = await q.get()\n        last  = last or price\n\n        if trailing_mgr().update(price):\n            trailing_stop_hits_total.inc()\n            await broker.close_all()\n            await PositionGuard().reset()\n\n            try:\n                cli = get_client()\n                col = cli.collections.get(\"TradeLog\")\n                uuid = col.query.fetch_objects(limit=1)[0].uuid\n                col.data.update(uuid, {\"trail_sl_hit\": \"true\"})\n            except Exception:\n                pass\n            last = price\n            continue\n\n        direction = \"BUY\" if price > last else \"SELL\" if price < last else \"HOLD\"\n        if filt.push(direction):\n            pos = await PositionGuard().get()\n\n            cache_key = {\"sym\": broker.symbol, \"side\": direction,\n                         \"zone\": round(price * 500) / 500}\n            significant = event_cls.push(price) and not hit_or_set(cache_key)\n\n            if significant:\n                sig, prompt, extra = await llm_decide(price, pos, broker.spec)\n            else:\n                raw, _ = await ask_local_llm(f\"eth price {price:.2f}, answer BUY SELL HOLD\")\n                sig, prompt, extra = raw.strip().upper()[:4], \"gemma quick\", {\"gemma_raw\": raw}\n\n            await agent_decide_and_execute(sig, price, broker,\n                                           prompt=prompt, extra=extra)\n        last = price",
    "tags": [
      "update_logic",
      "broker",
      "await",
      "prompt",
      "get",
      "sig",
      "true",
      "error_handling",
      "col",
      "price",
      "else",
      "extra",
      "last",
      "raw",
      "uuid",
      "direction"
    ],
    "calls": [
      "PositionGuard",
      "agent_decide_and_execute",
      "ask_local_llm",
      "close_all",
      "fetch_objects",
      "get",
      "get_client",
      "hit_or_set",
      "inc",
      "llm_decide",
      "push",
      "reset",
      "round",
      "strip",
      "trailing_mgr",
      "update",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 95,
    "endLine": 109,
    "signature": "Try:Try",
    "parentSignature": [
      "AsyncFunctionDef:llm_decide"
    ],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: Try:Try\n# Params: 无\n        try:\n            resp = await asyncio.to_thread(lambda: openai.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.2,\n                response_format={\"type\": \"json_object\"},\n                timeout=6\n            ))\n            gpt_latency_seconds.observe(time.time() - t0)\n            gpt_requests_total.inc()\n            data = json.loads(resp.choices[0].message.content)\n            return data.get(\"side\", \"HOLD\").upper(), prompt, data\n        except Exception as e:\n            logging.warning(\"GPT err %s\", e)\n            return \"HOLD\", prompt, {\"err\": str(e)}",
    "tags": [
      "time",
      "gpt",
      "asyncio",
      "openai",
      "data",
      "content",
      "prompt",
      "await",
      "thread",
      "error_handling",
      "try",
      "lambda",
      "json",
      "hold",
      "resp"
    ],
    "calls": [
      "create",
      "get",
      "inc",
      "loads",
      "observe",
      "str",
      "time",
      "to_thread",
      "upper",
      "warning"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 164,
    "endLine": 177,
    "signature": "If:If",
    "parentSignature": [
      "AsyncFunctionDef:main"
    ],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: If:If\n# Params: 无\n        if trailing_mgr().update(price):\n            trailing_stop_hits_total.inc()\n            await broker.close_all()\n            await PositionGuard().reset()\n\n            try:\n                cli = get_client()\n                col = cli.collections.get(\"TradeLog\")\n                uuid = col.query.fetch_objects(limit=1)[0].uuid\n                col.data.update(uuid, {\"trail_sl_hit\": \"true\"})\n            except Exception:\n                pass\n            last = price\n            continue",
    "tags": [
      "update_logic",
      "inc",
      "broker",
      "await",
      "total",
      "get",
      "mgr",
      "col",
      "error_handling",
      "stop",
      "trailing",
      "price",
      "hits",
      "cli",
      "uuid"
    ],
    "calls": [
      "PositionGuard",
      "close_all",
      "fetch_objects",
      "get",
      "get_client",
      "inc",
      "reset",
      "trailing_mgr",
      "update"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/kk/ws_main.py",
    "startLine": 180,
    "endLine": 194,
    "signature": "If:If",
    "parentSignature": [
      "AsyncFunctionDef:main"
    ],
    "moduleName": "kk",
    "importPath": "/root/kk",
    "content": "# Summary: If:If\n# Params: 无\n        if filt.push(direction):\n            pos = await PositionGuard().get()\n\n            cache_key = {\"sym\": broker.symbol, \"side\": direction,\n                         \"zone\": round(price * 500) / 500}\n            significant = event_cls.push(price) and not hit_or_set(cache_key)\n\n            if significant:\n                sig, prompt, extra = await llm_decide(price, pos, broker.spec)\n            else:\n                raw, _ = await ask_local_llm(f\"eth price {price:.2f}, answer BUY SELL HOLD\")\n                sig, prompt, extra = raw.strip().upper()[:4], \"gemma quick\", {\"gemma_raw\": raw}\n\n            await agent_decide_and_execute(sig, price, broker,\n                                           prompt=prompt, extra=extra)",
    "tags": [
      "key",
      "broker",
      "await",
      "prompt",
      "sig",
      "push",
      "significant",
      "decide",
      "price",
      "extra",
      "llm",
      "pos",
      "cache",
      "raw",
      "direction"
    ],
    "calls": [
      "PositionGuard",
      "agent_decide_and_execute",
      "ask_local_llm",
      "get",
      "hit_or_set",
      "llm_decide",
      "push",
      "round",
      "strip",
      "upper"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/collector.py",
    "startLine": 23,
    "endLine": 56,
    "signature": "While:While",
    "parentSignature": [],
    "moduleName": "ingest",
    "importPath": "/root/windking/ingest",
    "content": "# Summary: While:While\n# Params: 无\nwhile True:\n    now = datetime.utcnow()\n\n    # 遍历每个配置的 API，检查是否达到执行时间\n    for api in cfg:\n        name = api['name']\n        \n        # 如果当前时间大于等于计划执行时间\n        if now >= schedule[name]:\n            params = api.get(\"params\", {})\n            headers = {}\n\n            # 如果需要API密钥，设置Authorization头\n            if api['key_env']:\n                headers[\"Authorization\"] = f\"Bearer {os.getenv(api['key_env'], '')}\"\n\n            try:\n                # 请求 API\n                res = requests.get(api['base_url'], params=params, headers=headers, timeout=10)\n                data = res.json()  # 将返回的数据解析为 JSON\n\n                # 将获取的数据写入 Redis Stream\n                r.xadd(name, {\"ts\": now.isoformat(), \"payload\": json.dumps(data)})\n                print(f\"[{now}] pulled {name}\")\n\n            except Exception as e:\n                # 错误处理\n                print(f\"ERR {name}: {e}\", file=sys.stderr)\n\n            # 计算下一次任务执行时间\n            schedule[name] = croniter(api['cron'], schedule[name]).get_next(datetime)\n    \n    # 每次循环后等待 5 秒再继续检查\n    time.sleep(5)",
    "tags": [
      "",
      "=",
      "(",
      "'",
      "_",
      "]",
      ".",
      "error_handling",
      ")",
      "api",
      "[",
      ":",
      "#",
      ",",
      "\""
    ],
    "calls": [
      "croniter",
      "dumps",
      "get",
      "get_next",
      "getenv",
      "isoformat",
      "json",
      "print",
      "sleep",
      "utcnow",
      "xadd"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/collector.py",
    "startLine": 27,
    "endLine": 53,
    "signature": "For:For",
    "parentSignature": [],
    "moduleName": "ingest",
    "importPath": "/root/windking/ingest",
    "content": "# Summary: For:For\n# Params: 无\n    for api in cfg:\n        name = api['name']\n        \n        # 如果当前时间大于等于计划执行时间\n        if now >= schedule[name]:\n            params = api.get(\"params\", {})\n            headers = {}\n\n            # 如果需要API密钥，设置Authorization头\n            if api['key_env']:\n                headers[\"Authorization\"] = f\"Bearer {os.getenv(api['key_env'], '')}\"\n\n            try:\n                # 请求 API\n                res = requests.get(api['base_url'], params=params, headers=headers, timeout=10)\n                data = res.json()  # 将返回的数据解析为 JSON\n\n                # 将获取的数据写入 Redis Stream\n                r.xadd(name, {\"ts\": now.isoformat(), \"payload\": json.dumps(data)})\n                print(f\"[{now}] pulled {name}\")\n\n            except Exception as e:\n                # 错误处理\n                print(f\"ERR {name}: {e}\", file=sys.stderr)\n\n            # 计算下一次任务执行时间\n            schedule[name] = croniter(api['cron'], schedule[name]).get_next(datetime)",
    "tags": [
      "",
      "=",
      "(",
      "'",
      "_",
      "]",
      "name",
      "[",
      "error_handling",
      ")",
      "api",
      ".",
      ":",
      ",",
      "\""
    ],
    "calls": [
      "croniter",
      "dumps",
      "get",
      "get_next",
      "getenv",
      "isoformat",
      "json",
      "print",
      "xadd"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/collector.py",
    "startLine": 31,
    "endLine": 53,
    "signature": "If:If",
    "parentSignature": [],
    "moduleName": "ingest",
    "importPath": "/root/windking/ingest",
    "content": "# Summary: If:If\n# Params: 无\n        if now >= schedule[name]:\n            params = api.get(\"params\", {})\n            headers = {}\n\n            # 如果需要API密钥，设置Authorization头\n            if api['key_env']:\n                headers[\"Authorization\"] = f\"Bearer {os.getenv(api['key_env'], '')}\"\n\n            try:\n                # 请求 API\n                res = requests.get(api['base_url'], params=params, headers=headers, timeout=10)\n                data = res.json()  # 将返回的数据解析为 JSON\n\n                # 将获取的数据写入 Redis Stream\n                r.xadd(name, {\"ts\": now.isoformat(), \"payload\": json.dumps(data)})\n                print(f\"[{now}] pulled {name}\")\n\n            except Exception as e:\n                # 错误处理\n                print(f\"ERR {name}: {e}\", file=sys.stderr)\n\n            # 计算下一次任务执行时间\n            schedule[name] = croniter(api['cron'], schedule[name]).get_next(datetime)",
    "tags": [
      "",
      "=",
      "(",
      "'",
      "_",
      "]",
      "[",
      "error_handling",
      ")",
      "api",
      ".",
      "{",
      ",",
      "}",
      "\""
    ],
    "calls": [
      "croniter",
      "dumps",
      "get",
      "get_next",
      "getenv",
      "isoformat",
      "json",
      "print",
      "xadd"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/collector.py",
    "startLine": 39,
    "endLine": 50,
    "signature": "Try:Try",
    "parentSignature": [],
    "moduleName": "ingest",
    "importPath": "/root/windking/ingest",
    "content": "# Summary: Try:Try\n# Params: 无\n            try:\n                # 请求 API\n                res = requests.get(api['base_url'], params=params, headers=headers, timeout=10)\n                data = res.json()  # 将返回的数据解析为 JSON\n\n                # 将获取的数据写入 Redis Stream\n                r.xadd(name, {\"ts\": now.isoformat(), \"payload\": json.dumps(data)})\n                print(f\"[{now}] pulled {name}\")\n\n            except Exception as e:\n                # 错误处理\n                print(f\"ERR {name}: {e}\", file=sys.stderr)",
    "tags": [
      "",
      "(",
      "=",
      "_",
      ".",
      "error_handling",
      ")",
      "#",
      "api",
      ":",
      "{",
      "json",
      ",",
      "}",
      "\""
    ],
    "calls": [
      "dumps",
      "get",
      "isoformat",
      "json",
      "print",
      "xadd"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/etl_container/etl_loader.py",
    "startLine": 23,
    "endLine": 34,
    "signature": "FunctionDef:process_stream",
    "parentSignature": [],
    "moduleName": "etl_container",
    "importPath": "/root/windking/ingest/etl_container",
    "content": "# Summary: 函数 process_stream\n# Params: stream:None=None, count:None=20\ndef process_stream(stream, count=20):\n    for _, entries in r.xread({stream: \"0\"}, count=count, block=0):\n        for _id, kv in entries:\n            obj = {\n                \"id\": _id.decode(),        # MeiliSearch 主键\n                \"stream\": stream,\n                \"timestamp\": kv[b\"ts\"].decode(),\n                \"data\": json.loads(kv[b\"payload\"].decode())\n            }\n            load_to_weaviate(obj)\n            load_to_meili(obj)\n            print(f\"{datetime.utcnow().isoformat()} stored {stream} {_id.decode()}\")",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "stream",
      ".",
      ")",
      "id",
      ":",
      "{",
      ",",
      "count",
      "decode",
      "}",
      "\""
    ],
    "calls": [
      "decode",
      "isoformat",
      "load_to_meili",
      "load_to_weaviate",
      "loads",
      "print",
      "process_stream",
      "utcnow",
      "xread"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  },
  {
    "filePath": "/root/windking/ingest/etl_loader.py",
    "startLine": 23,
    "endLine": 34,
    "signature": "FunctionDef:process_stream",
    "parentSignature": [],
    "moduleName": "ingest",
    "importPath": "/root/windking/ingest",
    "content": "# Summary: 函数 process_stream\n# Params: stream:None=None, count:None=20\ndef process_stream(stream, count=20):\n    for _, entries in r.xread({stream: \"0\"}, count=count, block=0):\n        for _id, kv in entries:\n            obj = {\n                \"id\": _id.decode(),        # MeiliSearch 主键\n                \"stream\": stream,\n                \"timestamp\": kv[b\"ts\"].decode(),\n                \"data\": json.loads(kv[b\"payload\"].decode())\n            }\n            load_to_weaviate(obj)\n            load_to_meili(obj)\n            print(f\"{datetime.utcnow().isoformat()} stored {stream} {_id.decode()}\")",
    "tags": [
      "",
      "(",
      "=",
      "_",
      "stream",
      ".",
      ")",
      "id",
      ":",
      "{",
      ",",
      "count",
      "decode",
      "}",
      "\""
    ],
    "calls": [
      "decode",
      "isoformat",
      "load_to_meili",
      "load_to_weaviate",
      "loads",
      "print",
      "process_stream",
      "utcnow",
      "xread"
    ],
    "called_by": [],
    "imports": [],
    "docstring": ""
  }
]